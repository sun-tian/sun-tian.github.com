I"D <h1 id="react组件的生命周期"><a href="https://www.runoob.com/jsref/jsref-substring.html">React组件的生命周期</a></h1>

<h1 id="react组件的生命周期-1">React组件的生命周期</h1>

<h3 id="前言">前言</h3>

<blockquote>
  <p>在vue中我们了解到，钩子函数就是vue生命周期中有一定执行顺序的接口函数，用户可以根据这些暴露的函数处理自己的数据，渲染页面.可以这样理解，钩子，钩子，挂载自己的东西</p>
</blockquote>

<blockquote>
  <p>React组件也提供了生命周期的钩子函数去响应组件不同时刻的状态</p>
</blockquote>

<h3 id="react生命周期">React生命周期</h3>

<p><img src="https://user-gold-cdn.xitu.io/2018/3/12/16218b40c25ebecd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<blockquote>
  <p>由图我们可以简单了解到，React生命周期主要分为三个阶段：初始化，存在期，销毁期，每个生命周期阶段调用的钩子函数会略有不同，下面来详细了解下：</p>
</blockquote>

<h3 id="一初始化实例化">一、初始化/实例化</h3>

<p><strong>1.getDefaultProps</strong></p>

<blockquote>
  <p>这个方法是用来设置组件默认的props，组件生命周期只会调用一次。但是只适合React.createClass直接创建的组件(使用ES6/ES7创建的这个方法不可使用)，ES6/ES7可以使用下面方式：</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//es7
class Component {
  static defaultProps = {
      name:KK,
      age:18
  }
}
//或者也可以在外面定义es6
//Compnent.defaultProps
</code></pre></div></div>

<p><strong>2.getInitialState</strong></p>

<blockquote>
  <p>设置state初始值，getDefaultProps只适合React.createClass使用。使用ES6初始化state方法如下：</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Component extends React.Component{
  constructor(){
    super();
    this.state = {
      num:-1
    }
  }
}
</code></pre></div></div>

<blockquote>
  <p>在这个方法中如果你想访问this.props</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Component extends React.Component{
  constructor(props){
    super(props)//=&gt;类似与call继承
    this.state = {
      num:-1
    }
    console.log(this.props)
  }
}
</code></pre></div></div>

<p><strong>3.componentWillMount</strong></p>

<blockquote>
  <ul>
    <li>在完成首次渲染之前调用，此时仍可以修改组件的state。</li>
    <li>因为componentWillMount是在render之前执行，所以在这个方法中setState不会发生重新渲染(re-render);</li>
    <li>通常情况下，推荐用constructor()方法代替;</li>
  </ul>
</blockquote>

<p><strong>4.render</strong></p>

<blockquote>
  <p>JSX通过这里，解析成对应的虚拟DOM,格式大致如下：</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Component extends React.Component{
  render(){
    return (
        &lt;div&gt;&lt;/div&gt;
    )
  }
}
</code></pre></div></div>

<p><strong>5.componentDidMount</strong></p>

<blockquote>
  <ul>
    <li>真实的DOM被渲染出来后调用，在该方法中可访问到真实的DOM元素。</li>
    <li>这里可以加载服务器数据</li>
    <li>这里可以使用setState()方法触发重新渲染(re-render);</li>
  </ul>
</blockquote>

<h3 id="二存在期">二、存在期</h3>

<p><strong>1.componentWillReceiveProps</strong></p>

<blockquote>
  <ul>
    <li>每当我们通过父组件更新子组件props时（这个也是唯一途径），这个方法就会被调用。</li>
    <li>如果你只是调用this.setState()而不是从外部传入props, 那么不会触发componentWillReceiveProps(nextProps)函数；这就意味着: this.setState()方法不会触发componentWillReceiveProps(), props的改变或者props没有改变才会触发这个方法;</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentWillReceiveProps(nextProps){}
</code></pre></div></div>

<p><strong>2.shouldComponentUpdate</strong></p>

<blockquote>
  <ul>
    <li>在接收到新props或state时，或者说在componentWillReceiveProps(nextProps)后触发</li>
    <li>字面意思，是否应该更新组件，默认返回true。当返回false时，后期函数就不会调用，组件不会再次渲染。</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shouldComponentUpdate(nextProps,nextState){}
</code></pre></div></div>

<p><strong>3.componentWillUpdate</strong></p>

<blockquote>
  <p>在props或state发生改变或者shouldComponentUpdate(nextProps, nextState)触发后, 在render()之前</p>
</blockquote>

<p><strong>4.render</strong></p>

<blockquote>
  <p>和实例化时的render一样</p>
</blockquote>

<p><strong>5.componentDidUpdate</strong></p>

<blockquote>
  <p>这个方法在更新真实的DOM成功后调用，当我们需要访问真实的DOM时，这个方法就也经常用到</p>
</blockquote>

<h3 id="三销毁期">三、销毁期</h3>

<p><strong>componentWillUnmount</strong></p>

<blockquote>
  <ul>
    <li>在组件卸载(unmounted)或销毁(destroyed)之前</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>这个方法可以让你处理一些必要的清理操作，比如无效的timers、interval，或者取消网络请求，或者清理任何在componentDidMount()中创建的DOM元素(elements);</li>
  </ul>
</blockquote>

<h3 id="测试代码">测试代码：</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import React from 'react';
import ReactDOM from 'react-dom';

class Temp extends React.Component {
    constructor() {
        super();
        this.state = {msg: 'hello world!'};
        console.log(`1=&gt;执行构造函数`);
    }
    componentWillMount() {
        console.log(`2=&gt;第一次渲染之前`);
    }
    componentDidMount() {
        console.log(`4=&gt;第一次渲染之后`);
        /*setTimeout(() =&gt; {
            //=&gt;2000MS后打算重新渲染组件(修改状态)
            this.setState({
                msg: 'hello world!'
            });
        }, 2000);*/
    }
   
    shouldComponentUpdate(nextProps, nextState) {
        console.log(`5=&gt;是否允许更新，返回TRUE是允许，反之不允许`, nextProps, nextState);

        /*if (this.state.msg === nextState.msg) {
            //=&gt;重新设置的属性值和之前的是一样的，此时就不需要重新的进行渲染
            return false;
        }*/
        return true;
    }

    componentWillUpdate(nextProps, nextState) {
        console.log(`6=&gt;更新之前`, nextState);
    }

    componentDidUpdate() {
        console.log(`7=&gt;更新之后`, this.state.msg);
    }

    //=&gt;属性改变
    componentWillReceiveProps(nextProps) {
        //=&gt;属性更改的时候，它优先于shouldComponentUpdate执行（它控制的是属性已经修改了，而SHOULD控制的是允许组件重新渲染）
        //=&gt;此时获取的PROPS的值还是原始值
        console.log(`属性更改了`, nextProps);
    }

    render() {
        console.log(`3=&gt;渲染组件`, this.props);
        return &lt;h2&gt;
            {this.state.msg}
        &lt;/h2&gt;;
    }
}

class Box extends React.Component {
    constructor() {
        super();
        this.state = {n: 10};
    }

    componentDidMount() {
        setTimeout(() =&gt; {
            this.setState({
                n: ++this.state.n
            });
        }, 2000);
    }

    render() {
        return &lt;div&gt;
            &lt;h2&gt;请说：&lt;/h2&gt;
            &lt;Temp n={this.state.n}/&gt;
            {/*父组件把自己的状态信息当做属性值传递给子组件*/}
        &lt;/div&gt;;
    }
}

ReactDOM.render(&lt;div&gt;
    &lt;Box/&gt;
&lt;/div&gt;, window.root);
</code></pre></div></div>
:ET