I"p&<h1 id="90条写python程序的建议">90条写Python程序的建议</h1>

<h2 id="1-首先">1. 首先</h2>

<p>建议1、理解Pythonic概念—-详见Python中的《Python之禅》</p>

<p>建议2、编写Pythonic代码</p>

<p>（1）避免不规范代码，比如只用大小写区分变量、使用容易混淆的变量名、害怕过长变量名等。有时候长的变量名会使代码更加具有可读性。</p>

<p>（2）深入学习Python相关知识，比如语言特性、库特性等，比如Python演变过程等。深入学习一两个业内公认的Pythonic的代码库，比如Flask等。</p>

<p>建议3：理解Python与C的不同之处，比如缩进与{}，单引号双引号，三元操作符？，Switch-Case语句等。</p>

<p>建议4：在代码中适当添加注释</p>

<p>建议5：适当添加空行使代码布局更加合理</p>

<p>建议6：编写函数的4个原则</p>

<p>（1）函数设计要尽量短小，嵌套层次不宜过深</p>

<p>（2）函数声明应该做到合理、简单、易用</p>

<p>（3）函数参数设计应该考虑向下兼容</p>

<p>（4）一个函数只做一件事，尽量保证函数粒度的一致性</p>

<p>建议7：将常量集中在一个文件，且常量名尽量使用全大写字母</p>

<h2 id="2-编程惯用法">2. 编程惯用法</h2>

<p>建议8：利用assert语句来发现问题，但要注意，断言assert会影响效率</p>

<p>建议9：数据交换值时不推荐使用临时变量，而是直接a, b = b, a</p>

<p>建议10：充分利用惰性计算（Lazy evaluation）的特性，从而避免不必要的计算</p>

<p>建议11：理解枚举替代实现的缺陷（最新版Python中已经加入了枚举特性）</p>

<p>建议12：不推荐使用type来进行类型检查，因为有些时候type的结果并不一定可靠。如果有需求，建议使用isinstance函数来代替</p>

<p>建议13：尽量将变量转化为浮点类型后再做除法（Python3以后不用考虑）</p>

<p>建议14：警惕eval()函数的安全漏洞，有点类似于SQL注入</p>

<p>建议15：使用enumerate()同时获取序列迭代的索引和值</p>

<p>建议16：分清==和is的适用场景，特别是在比较字符串等不可变类型变量时（详见评论）</p>

<p>建议17：尽量使用Unicode。在Python2中编码是很让人头痛的一件事，但Python3就不用过多考虑了</p>

<p>建议18：构建合理的包层次来管理Module</p>

<h2 id="3-基础用法">3. 基础用法</h2>

<p>建议19：有节制的使用from…import语句，防止污染命名空间</p>

<p>建议20：优先使用absolute import来导入模块（Python3中已经移除了relative import）</p>

<p>建议21：i+=1不等于++i，在Python中，++i前边的加号仅表示正，不表示操作</p>

<p>建议22：习惯使用with自动关闭资源，特别是在文件读写中</p>

<p>建议23：使用else子句简化循环（异常处理）</p>

<p>建议24：遵循异常处理的几点基本原则</p>

<p>（1）注意异常的粒度，try块中尽量少写代码</p>

<p>（2）谨慎使用单独的except语句，或except Exception语句，而是定位到具体异常</p>

<p>（3）注意异常捕获的顺序，在合适的层次处理异常</p>

<p>（4）使用更加友好的异常信息，遵守异常参数的规范</p>

<p>建议25：避免finally中可能发生的陷阱</p>

<p>建议26：深入理解None，正确判断对象是否为空。</p>

<p>建议27：连接字符串应优先使用join函数，而不是+操作</p>

<p>建议28：格式化字符串时尽量使用.format函数，而不是%形式</p>

<p>建议29：区别对待可变对象和不可变对象，特别是作为函数参数时</p>

<p>建议30：[], {}和()：一致的容器初始化形式。使用列表解析可以使代码更清晰，同时效率更高</p>

<p>建议31：函数传参数，既不是传值也不是传引用，而是传对象或者说对象的引用</p>

<p>建议32：警惕默认参数潜在的问题，特别是当默认参数为可变对象时</p>

<p>建议33：函数中慎用变长参数 <strong>args和</strong> <strong>kargs</strong></p>

<p>（1）这种使用太灵活，从而使得函数签名不够清晰，可读性较差</p>

<p>（2）如果因为函数参数过多而是用变长参数简化函数定义，那么一般该函数可以重构</p>

<p>建议34：深入理解str()和repr()的区别</p>

<p>（1）两者之间的目标不同：str主要面向客户，其目的是可读性，返回形式为用户友好性和可读性都比较高的字符串形式；而repr是面向Python解释器或者说Python开发人员，其目的是准确性，其返回值表示Python解释器内部的定义</p>

<p>（2）在解释器中直接输入变量，默认调用repr函数，而print(var)默认调用str函数</p>

<p>（3）repr函数的返回值一般可以用eval函数来还原对象</p>

<p>（4）两者分别调用对象的内建函数 <strong>__str__</strong> ()和 <strong>__repr__</strong> ()</p>

<p>建议35：分清静态方法staticmethod和类方法classmethod的使用场景</p>

<h2 id="4-库的使用">4. 库的使用</h2>

<p>建议36：掌握字符串的基本用法</p>

<p>建议37：按需选择sort()和sorted()函数</p>

<p>sort()是列表在就地进行排序，所以不能排序元组等不可变类型。</p>

<p>sorted()可以排序任意的可迭代类型，同时不改变原变量本身。</p>

<p>建议38：使用copy模块深拷贝对象，区分浅拷贝（shallow copy）和深拷贝（deep copy）</p>

<p>建议39：使用Counter进行计数统计，Counter是字典类的子类，在collections模块中</p>

<p>建议40：深入掌握ConfigParse</p>

<p>建议41：使用argparse模块处理命令行参数</p>

<p>建议42：使用pandas处理大型CSV文件</p>

<p>Python本身提供一个CSV文件处理模块，并提供reader、writer等函数。</p>

<p>Pandas可提供分块、合并处理等，适用于数据量大的情况，且对二维数据操作更方便。</p>

<p>建议43：使用ElementTree解析XML</p>

<p>建议44：理解模块pickle的优劣</p>

<p>优势：接口简单、各平台通用、支持的数据类型广泛、扩展性强</p>

<p>劣势：不保证数据操作的原子性、存在安全问题、不同语言之间不兼容</p>

<p>建议45：序列化的另一个选择JSON模块：load和dump操作</p>

<p>建议46：使用traceback获取栈信息</p>

<p>建议47：使用logging记录日志信息</p>

<p>建议48：使用threading模块编写多线程程序</p>

<p>建议49：使用Queue模块使多线程编程更安全</p>

<h2 id="5-设计模式">5. 设计模式</h2>

<p>建议50：利用模块实现单例模式</p>

<p>建议51：用mixin模式让程序更加灵活</p>

<p>建议52：用发布-订阅模式实现松耦合</p>

<p>建议53：用状态模式美化代码</p>

<h2 id="6-内部机制">6. 内部机制</h2>

<p>建议54：理解build-in对象</p>

<p>建议55：<strong>__init__</strong> ()不是构造方法，理解 <strong>__new__</strong> ()与它之间的区别</p>

<p>建议56：理解变量的查找机制，即作用域</p>

<p>局部作用域</p>

<p>全局作用域</p>

<p>嵌套作用域</p>

<p>内置作用域</p>

<p>建议57：为什么需要self参数</p>

<p>建议58：理解MRO（方法解析顺序）与多继承</p>

<p>建议59：理解描述符机制</p>

<p>建议60：区别 <strong>__getattr__</strong> ()与 <strong>__getattribute__</strong> ()方法之间的区别</p>

<p>建议61：使用更安全的property</p>

<p>建议62：掌握元类metaclass</p>

<p>建议63：熟悉Python对象协议</p>

<p>建议64：利用操作符重载实现中缀语法</p>

<p>建议65：熟悉Python的迭代器协议</p>

<p>建议66：熟悉Python的生成器</p>

<p>建议67：基于生成器的协程和greenlet，理解协程、多线程、多进程之间的区别</p>

<p>建议68：理解GIL的局限性</p>

<p>建议69：对象的管理和垃圾回收</p>

<h2 id="7-使用工具辅助项目开发">7. 使用工具辅助项目开发</h2>

<p>建议70：从PyPI安装第三方包</p>

<p>建议71：使用pip和yolk安装、管理包</p>

<p>建议72：做paster创建包</p>

<p>建议73：理解单元测试的概念</p>

<p>建议74：为包编写单元测试</p>

<p>建议75：利用测试驱动开发（TDD）提高代码的可测性</p>

<p>建议76：使用Pylint检查代码风格</p>

<p>代码风格审查</p>

<p>代码错误检查</p>

<p>发现重复以及不合理的代码，方便重构</p>

<p>高度的可配置化和可定制化</p>

<p>支持各种IDE和编辑器的集成</p>

<p>能够基于Python代码生成UML图</p>

<p>能够与Jenkins等持续集成工具相结合，支持自动代码审查</p>

<p>建议77：进行高效的代码审查</p>

<p>建议78：将包发布到PyPI</p>

<h2 id="8-性能剖析与优化">8. 性能剖析与优化</h2>

<p>建议79：了解代码优化的基本原则</p>

<p>建议80：借助性能优化工具</p>

<p>建议81：利用cProfile定位性能瓶颈</p>

<p>建议82：使用memory_profiler和objgraph剖析内存使用</p>

<p>建议83：努力降低算法复杂度</p>

<p>建议84：掌握循环优化的基本技巧</p>

<p>减少循环内部的计算</p>

<p>将显式循环改为隐式循环，当然这会牺牲代码的可读性</p>

<p>在循环中尽量引用局部变量</p>

<p>关注内层嵌套循环</p>

<p>建议85：使用生成器提高效率</p>

<p>建议86：使用不同的数据结构优化性能</p>

<p>建议87：充分利用set的优势</p>

<p>建议88：使用multiprocessing模块克服GIL缺陷</p>

<p>建议89：使用线程池提高效率</p>

<p>建议90：使用Cythonb编写扩展模块</p>

<p><a href="https://mp.weixin.qq.com/s/6Oy0IzWepqILG0VSbLTczw">Link</a></p>
:ET