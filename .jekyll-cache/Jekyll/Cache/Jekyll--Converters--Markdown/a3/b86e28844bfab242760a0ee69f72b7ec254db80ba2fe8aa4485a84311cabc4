I""<h1 id="浏览器的回流与重绘-reflow--repaint"><a href="https://juejin.im/post/6844903569087266823">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></h1>

<h2 id="写在前面">写在前面</h2>

<p>在讨论回流与重绘之前，我们要知道：</p>

<ol>
  <li>浏览器使用流式布局模型 (Flow Based Layout)。</li>
  <li>浏览器会把<code class="language-plaintext highlighter-rouge">HTML</code>解析成<code class="language-plaintext highlighter-rouge">DOM</code>，把<code class="language-plaintext highlighter-rouge">CSS</code>解析成<code class="language-plaintext highlighter-rouge">CSSOM</code>，<code class="language-plaintext highlighter-rouge">DOM</code>和<code class="language-plaintext highlighter-rouge">CSSOM</code>合并就产生了<code class="language-plaintext highlighter-rouge">Render Tree</code>。</li>
  <li>有了<code class="language-plaintext highlighter-rouge">RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li>
  <li>由于浏览器使用流式布局，对<code class="language-plaintext highlighter-rouge">Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code class="language-plaintext highlighter-rouge">table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code class="language-plaintext highlighter-rouge">table</code>布局的原因之一。</li>
</ol>

<p><strong>一句话：回流必将引起重绘，重绘不一定会引起回流。</strong></p>

<h2 id="回流-reflow">回流 (Reflow)</h2>

<p>当<code class="language-plaintext highlighter-rouge">Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>

<p>会导致回流的操作：</p>

<ul>
  <li>页面首次渲染</li>
  <li>浏览器窗口大小发生改变</li>
  <li>元素尺寸或位置发生改变</li>
  <li>元素内容变化（文字数量或图片大小等等）</li>
  <li>元素字体大小变化</li>
  <li>添加或者删除<strong>可见</strong>的<code class="language-plaintext highlighter-rouge">DOM</code>元素</li>
  <li>激活<code class="language-plaintext highlighter-rouge">CSS</code>伪类（例如：<code class="language-plaintext highlighter-rouge">:hover</code>）</li>
  <li>查询某些属性或调用某些方法</li>
</ul>

<p>一些常用且会导致回流的属性和方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">clientWidth</code>、<code class="language-plaintext highlighter-rouge">clientHeight</code>、<code class="language-plaintext highlighter-rouge">clientTop</code>、<code class="language-plaintext highlighter-rouge">clientLeft</code></li>
  <li><code class="language-plaintext highlighter-rouge">offsetWidth</code>、<code class="language-plaintext highlighter-rouge">offsetHeight</code>、<code class="language-plaintext highlighter-rouge">offsetTop</code>、<code class="language-plaintext highlighter-rouge">offsetLeft</code></li>
  <li><code class="language-plaintext highlighter-rouge">scrollWidth</code>、<code class="language-plaintext highlighter-rouge">scrollHeight</code>、<code class="language-plaintext highlighter-rouge">scrollTop</code>、<code class="language-plaintext highlighter-rouge">scrollLeft</code></li>
  <li><code class="language-plaintext highlighter-rouge">scrollIntoView()</code>、<code class="language-plaintext highlighter-rouge">scrollIntoViewIfNeeded()</code></li>
  <li><code class="language-plaintext highlighter-rouge">getComputedStyle()</code></li>
  <li><code class="language-plaintext highlighter-rouge">getBoundingClientRect()</code></li>
  <li><code class="language-plaintext highlighter-rouge">scrollTo()</code></li>
</ul>

<h2 id="重绘-repaint">重绘 (Repaint)</h2>

<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code class="language-plaintext highlighter-rouge">color</code>、<code class="language-plaintext highlighter-rouge">background-color</code>、<code class="language-plaintext highlighter-rouge">visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>

<h2 id="性能影响">性能影响</h2>

<p><strong>回流比重绘的代价要更高。</strong></p>

<p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p>

<p>现代浏览器会对频繁的回流或重绘操作进行优化：</p>

<p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p>

<p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">clientWidth</code>、<code class="language-plaintext highlighter-rouge">clientHeight</code>、<code class="language-plaintext highlighter-rouge">clientTop</code>、<code class="language-plaintext highlighter-rouge">clientLeft</code></li>
  <li><code class="language-plaintext highlighter-rouge">offsetWidth</code>、<code class="language-plaintext highlighter-rouge">offsetHeight</code>、<code class="language-plaintext highlighter-rouge">offsetTop</code>、<code class="language-plaintext highlighter-rouge">offsetLeft</code></li>
  <li><code class="language-plaintext highlighter-rouge">scrollWidth</code>、<code class="language-plaintext highlighter-rouge">scrollHeight</code>、<code class="language-plaintext highlighter-rouge">scrollTop</code>、<code class="language-plaintext highlighter-rouge">scrollLeft</code></li>
  <li><code class="language-plaintext highlighter-rouge">width</code>、<code class="language-plaintext highlighter-rouge">height</code></li>
  <li><code class="language-plaintext highlighter-rouge">getComputedStyle()</code></li>
  <li><code class="language-plaintext highlighter-rouge">getBoundingClientRect()</code></li>
</ul>

<p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p>

<h2 id="如何避免">如何避免</h2>

<h3 id="css">CSS</h3>

<ul>
  <li>避免使用<code class="language-plaintext highlighter-rouge">table</code>布局。</li>
  <li>尽可能在<code class="language-plaintext highlighter-rouge">DOM</code>树的最末端改变<code class="language-plaintext highlighter-rouge">class</code>。</li>
  <li>避免设置多层内联样式。</li>
  <li>将动画效果应用到<code class="language-plaintext highlighter-rouge">position</code>属性为<code class="language-plaintext highlighter-rouge">absolute</code>或<code class="language-plaintext highlighter-rouge">fixed</code>的元素上。</li>
  <li>避免使用<code class="language-plaintext highlighter-rouge">CSS</code>表达式（例如：<code class="language-plaintext highlighter-rouge">calc()</code>）。</li>
</ul>

<h3 id="javascript">JavaScript</h3>

<ul>
  <li>避免频繁操作样式，最好一次性重写<code class="language-plaintext highlighter-rouge">style</code>属性，或者将样式列表定义为<code class="language-plaintext highlighter-rouge">class</code>并一次性更改<code class="language-plaintext highlighter-rouge">class</code>属性。</li>
  <li>避免频繁操作<code class="language-plaintext highlighter-rouge">DOM</code>，创建一个<code class="language-plaintext highlighter-rouge">documentFragment</code>，在它上面应用所有<code class="language-plaintext highlighter-rouge">DOM操作</code>，最后再把它添加到文档中。</li>
  <li>也可以先为元素设置<code class="language-plaintext highlighter-rouge">display: none</code>，操作结束后再把它显示出来。因为在<code class="language-plaintext highlighter-rouge">display</code>属性为<code class="language-plaintext highlighter-rouge">none</code>的元素上进行的<code class="language-plaintext highlighter-rouge">DOM</code>操作不会引发回流和重绘。</li>
  <li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
  <li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>

<p><a href="https://juejin.im/post/6844903569087266823">Link</a></p>
:ET