I""&<h1 id="javascript初学者必看箭头函数"><a href="https://blog.fundebug.com/2017/05/25/arrow-function-for-beginner/">JavaScript初学者必看“箭头函数”</a></h1>

<p><strong>译者按:</strong> 箭头函数看上去只是语法的变动，其实也影响了<code class="language-plaintext highlighter-rouge">this</code>的作用域。</p>

<ul>
  <li>原文: <a href="https://hackernoon.com/javascript-arrow-functions-for-beginners-926947fc0cdc">JavaScript: Arrow Functions for Beginners</a></li>
  <li>译者: <a href="https://www.fundebug.com/">Fundebug</a></li>
</ul>

<p><strong>本文采用意译，版权归原作者所有</strong></p>

<p>本文我们介绍箭头(arrow)函数的优点。</p>

<h3 id="更简洁的语法">更简洁的语法</h3>

<p>我们先来按常规语法定义函数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function funcName(params) {
    return params + 2;
}
funcName(2);
// 4
</code></pre></div></div>

<p>该函数使用箭头函数可以使用仅仅一行代码搞定！</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var funcName = params =&gt; params + 2;
funcName(2);
// 4
</code></pre></div></div>

<p>是不是很酷！虽然是一个极端简洁的例子，但是很好的表述了箭头函数在写代码时的优势。我们来深入了解箭头函数的语法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parameters =&gt; {
    statements;
};
</code></pre></div></div>

<p>如果没有参数，那么可以进一步简化：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>() =&gt; {
    statements;
};
</code></pre></div></div>

<p>如果只有一个参数，可以省略括号:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parameters =&gt; {
    statements;
};
</code></pre></div></div>

<p>如果返回值仅仅只有一个表达式(expression), 还可以省略大括号：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parameters =&gt; expression

// 等价于:
function (parameters){
  return expression;
}
</code></pre></div></div>

<p>现在你已经学会了箭头函数的语法，我们来实战一下。打开 Chrome 浏览器开发者控制台，输入：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var double = num =&gt; num * 2;
</code></pre></div></div>

<p>我们将变量<code class="language-plaintext highlighter-rouge">double</code>绑定到一个箭头函数，该函数有一个参数<code class="language-plaintext highlighter-rouge">num</code>, 返回 <code class="language-plaintext highlighter-rouge">num * 2</code>。 调用该函数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>double(2);
// 4

double(3);
// 6
</code></pre></div></div>

<p><strong>一行代码搞定 BUG 监控：<a href="https://www.fundebug.com/">Fundebug</a></strong></p>

<h3 id="没有局部this的绑定">没有局部<code class="language-plaintext highlighter-rouge">this</code>的绑定</h3>

<p>和一般的函数不同，箭头函数不会绑定<code class="language-plaintext highlighter-rouge">this</code>。 或者说箭头函数不会改变<code class="language-plaintext highlighter-rouge">this</code>本来的绑定。
我们用一个例子来说明：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Counter() {
    this.num = 0;
}
var a = new Counter();
</code></pre></div></div>

<p>因为使用了关键字<code class="language-plaintext highlighter-rouge">new</code>构造，Counter()函数中的<code class="language-plaintext highlighter-rouge">this</code>绑定到一个新的对象，并且赋值给<code class="language-plaintext highlighter-rouge">a</code>。通过<code class="language-plaintext highlighter-rouge">console.log</code>打印<code class="language-plaintext highlighter-rouge">a.num</code>，会输出 0。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>console.log(a.num);
// 0
</code></pre></div></div>

<p>如果我们想每过一秒将<code class="language-plaintext highlighter-rouge">a.num</code>的值加 1，该如何实现呢？可以使用<code class="language-plaintext highlighter-rouge">setInterval()</code>函数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Counter() {
    this.num = 0;
    this.timer = setInterval(function add() {
        this.num++;
        console.log(this.num);
    }, 1000);
}
</code></pre></div></div>

<p>我们来看一下输出结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var b = new Counter();
// NaN
// NaN
// NaN
// ...
</code></pre></div></div>

<p>你会发现，每隔一秒都会有一个<code class="language-plaintext highlighter-rouge">NaN</code>打印出来，而不是累加的数字。到底哪里错了呢？
首先使用如下语句停止<code class="language-plaintext highlighter-rouge">setInterval</code>函数的连续执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clearInterval(b.timer);
</code></pre></div></div>

<p>我们来尝试理解为什么出错：根据上一篇博客讲解的规则，首先函数<code class="language-plaintext highlighter-rouge">setInterval</code>没有被某个声明的对象调用，也没有使用<code class="language-plaintext highlighter-rouge">new</code>关键字，再之没有使用<code class="language-plaintext highlighter-rouge">bind</code>, <code class="language-plaintext highlighter-rouge">call</code>和<code class="language-plaintext highlighter-rouge">apply</code>。<code class="language-plaintext highlighter-rouge">setInterval</code>只是一个普通的函数。实际上<code class="language-plaintext highlighter-rouge">setInterval</code>里面的<code class="language-plaintext highlighter-rouge">this</code>绑定到全局对象的。我们可以通过将<code class="language-plaintext highlighter-rouge">this</code>打印出来验证这一点：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Counter() {
    this.num = 0;
    this.timer = setInterval(function add() {
        console.log(this);
    }, 1000);
}
var b = new Counter();
</code></pre></div></div>

<p>你会发现，整个<code class="language-plaintext highlighter-rouge">window</code>对象被打印出来。 使用如下命令停止打印：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clearInterval(b.timer);
</code></pre></div></div>

<p>回到之前的函数，之所以打印<code class="language-plaintext highlighter-rouge">NaN</code>，是因为<code class="language-plaintext highlighter-rouge">this.num</code>绑定到<code class="language-plaintext highlighter-rouge">window</code>对象的<code class="language-plaintext highlighter-rouge">num</code>，而<code class="language-plaintext highlighter-rouge">window.num</code>未定义。</p>

<p>那么，我们如何解决这个问题呢？使用箭头函数！使用箭头函数就不会导致<code class="language-plaintext highlighter-rouge">this</code>被绑定到全局对象。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Counter() {
    this.num = 0;
    this.timer = setInterval(() =&gt; {
        this.num++;
        console.log(this.num);
    }, 1000);
}
var b = new Counter();
// 1
// 2
// 3
// ...
</code></pre></div></div>

<p>通过<code class="language-plaintext highlighter-rouge">Counter</code>构造函数绑定的<code class="language-plaintext highlighter-rouge">this</code>将会被保留。在<code class="language-plaintext highlighter-rouge">setInterval</code>函数中，<code class="language-plaintext highlighter-rouge">this</code>依然指向我们新创建的<code class="language-plaintext highlighter-rouge">b</code>对象。</p>

<p>为了验证刚刚的说法，我们可以将 <code class="language-plaintext highlighter-rouge">Counter</code>函数中的<code class="language-plaintext highlighter-rouge">this</code>绑定到<code class="language-plaintext highlighter-rouge">that</code>, 然后在<code class="language-plaintext highlighter-rouge">setInterval</code>中判断<code class="language-plaintext highlighter-rouge">this</code>和<code class="language-plaintext highlighter-rouge">that</code>是否相同。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Counter() {
    var that = this;
    this.timer = setInterval(() =&gt; {
        console.log(this === that);
    }, 1000);
}
var b = new Counter();
// true
// true
// ...
</code></pre></div></div>

<p>正如我们期望的，打印值每次都是<code class="language-plaintext highlighter-rouge">true</code>。最后，结束刷屏的打印：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clearInterval(b.timer);
</code></pre></div></div>

<h3 id="总结">总结</h3>

<ul>
  <li>箭头函数写代码拥有更加简洁的语法；</li>
  <li>不会绑定<code class="language-plaintext highlighter-rouge">this</code>。</li>
</ul>
:ET