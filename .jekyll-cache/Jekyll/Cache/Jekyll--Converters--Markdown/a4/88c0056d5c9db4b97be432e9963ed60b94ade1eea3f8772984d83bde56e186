I"⁄?<h1 id="1---sequence-to-sequence-learning-with-neural-networks">1 - Sequence to Sequence Learning with Neural Networks</h1>

<p>In this series we‚Äôll be building a machine learning model to go from once sequence to another, using PyTorch and TorchText. This will be done on German to English translations, but the models can be applied to any problem that involves going from one sequence to another, such as summarization.</p>

<p>In this first notebook, we‚Äôll start simple to understand the general concepts by implementing the model from the <a href="https://arxiv.org/abs/1409.3215">Sequence to Sequence Learning with Neural Networks</a> paper.</p>

<h2 id="introduction">Introduction</h2>

<p>The most common sequence-to-sequence (seq2seq) models are <em>encoder-decoder</em> models, which (commonly) use a <em>recurrent neural network</em> (RNN) to <em>encode</em> the source (input) sentence into a single vector. In this notebook, we‚Äôll refer to this single vector as a <em>context vector</em>. You can think of the context vector as being an abstract representation of the entire input sentence. This vector is then <em>decoded</em> by a second RNN which learns to output the target (output) sentence by generating it one word at a time.</p>

<p><img src="https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@1.0/assets/img/blog/190828-seq2seq1.png" alt="seq2seq1" /></p>

<p>The above image shows an example translation. The input/source sentence, ‚Äúguten morgen‚Äù, is input into the encoder (green) one word at a time. We also append a <em>start of sequence</em> (<code class="language-plaintext highlighter-rouge">&lt;sos&gt;</code>) and <em>end of sequence</em> (<code class="language-plaintext highlighter-rouge">&lt;eos&gt;</code>) token to the start and end of sentence, respectively. At each time-step, the input to the encoder RNN is both the current word, $x_t$, as well as the hidden state from the previous time-step, $h_{t-1}$, and the encoder RNN outputs a new hidden state $h_t$. You can think of the hidden state as a vector representation of the sentence so far. The RNN can be represented as a function of both of $x_t$ and $h_{t-1}$:</p>

\[h_t = \text{EncoderRNN}(x_t, h_{t-1})\]

<p>We‚Äôre using the term RNN generally here, it could be any recurrent architecture, such as an <em>LSTM</em> (Long Short-Term Memory) or a <em>GRU</em> (Gated Recurrent Unit).</p>

<p>Here, we have $X = {x_1, x_2, ‚Ä¶, x_T}$ , where \(x_1 = \text{&lt;sos&gt;}, x_2 = \text{guten}\) , etc. The initial hidden state, $h_0$, is usually either initialized to zeros or a learned parameter.</p>

<p>Once the final word, $x_T$, has been passed into the RNN, we use the final hidden state, $h_T$, as the context vector, i.e. $h_T = z$. This is a vector representation of the entire source sentence.</p>

<p>Now we have our context vector, $z$, we can start decoding it to get the target sentence, ‚Äúgood morning‚Äù. Again, we append start and end of sequence tokens to the target sentence. At each time-step, the input to the decoder RNN (blue) is the current word, $y_t$, as well as the hidden state from the previous time-step, $s_{t-1}$, where the initial decoder hidden state, $s_0$, is the context vector, $s_0 = z = h_T$, i.e. the initial decoder hidden state is the final encoder hidden state. Thus, similar to the encoder, we can represent the decoder as:</p>

\[s_t = \text{DecoderRNN}(y_t, s_{t-1})\]

<p>In the decoder, we need to go from the hidden state to an actual word, therefore at each time-step we use $s_t$ to predict (by passing it through a <code class="language-plaintext highlighter-rouge">Linear</code> layer, shown in purple) what we think is the next word in the sequence, $\hat{y}_t$.</p>

\[\hat{y}_t = f(s_t)\]

<p>We always use <code class="language-plaintext highlighter-rouge">&lt;sos&gt;</code> for the first input to the decoder, $y_1$, but for subsequent inputs, $y_{t&gt;1}$, we will sometimes use the actual, ground truth next word in the sequence, $y_t$ and sometimes use the word predicted by our decoder, $\hat{y}_{t-1}$. This is called <em>teacher forcing</em>, and you can read about it more <a href="https://machinelearningmastery.com/teacher-forcing-for-recurrent-neural-networks/">here</a>.</p>

<p>When training/testing our model, we always know how many words are in our target sentence, so we stop generating words once we hit that many. During inference (i.e. real world usage) it is common to keep generating words until the model outputs an <code class="language-plaintext highlighter-rouge">&lt;eos&gt;</code> token or after a certain amount of words have been generated.</p>

<p>Once we have our predicted target sentence, $\hat{Y} = { \hat{y}_1, \hat{y}_2, ‚Ä¶, \hat{y}_T }$, we compare it against our actual target sentence, $Y = { y_1, y_2, ‚Ä¶, y_T }$, to calculate our loss. We then use this loss to update all of the parameters in our model.</p>

<h2 id="preparing-data">Preparing Data</h2>

<p>We‚Äôll be coding up the models in PyTorch and using TorchText to help us do all of the pre-processing required. We‚Äôll also be using spaCy to assist in the tokenization of the data.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="n">optim</span>

<span class="kn">from</span> <span class="nn">torchtext.datasets</span> <span class="kn">import</span> <span class="n">TranslationDataset</span><span class="p">,</span> <span class="n">Multi30k</span>
<span class="kn">from</span> <span class="nn">torchtext.data</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">BucketIterator</span>

<span class="kn">import</span> <span class="nn">spacy</span>

<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>
</code></pre></div></div>

<p>We‚Äôll set the random seeds for deterministic results.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SEED</span> <span class="o">=</span> <span class="mi">1234</span>

<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">SEED</span><span class="p">)</span>
<span class="n">torch</span><span class="p">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">SEED</span><span class="p">)</span>
<span class="n">torch</span><span class="p">.</span><span class="n">backends</span><span class="p">.</span><span class="n">cudnn</span><span class="p">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div></div>

<p>Next, we‚Äôll create the tokenizers. A tokenizer is used to turn a string containing a sentence into a list of individual tokens that make up that string, e.g. ‚Äúgood morning!‚Äù becomes [‚Äúgood‚Äù, ‚Äúmorning‚Äù, ‚Äú!‚Äù]. We‚Äôll start talking about the sentences being a sequence of tokens from now, instead of saying they‚Äôre a sequence of words. What‚Äôs the difference? Well, ‚Äúgood‚Äù and ‚Äúmorning‚Äù are both words and tokens, but ‚Äú!‚Äù is a token, not a word.</p>

<p>spaCy has model for each language (‚Äúde‚Äù for German and ‚Äúen‚Äù for English) which need to be loaded so we can access the tokenizer of each model.</p>

<p><strong>Note</strong>: the models must first be downloaded using the following on the command line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python -m spacy download en
python -m spacy download de
</code></pre></div></div>

<p>We load the models as such:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spacy_de</span> <span class="o">=</span> <span class="n">spacy</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'de'</span><span class="p">)</span>
<span class="n">spacy_en</span> <span class="o">=</span> <span class="n">spacy</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'en'</span><span class="p">)</span>
</code></pre></div></div>

<p>Next, we create the tokenizer functions. These can be passed to TorchText and will take in the sentence as a string and return the sentence as a list of tokens.</p>

<p>In the paper we are implementing, they find it beneficial to reverse the order of the input which they believe ‚Äúintroduces many short term dependencies in the data that make the optimization problem much easier‚Äù.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tokenize_de</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="s">"""
    Tokenizes German text from a string into a list of strings (tokens) and reverses it
    """</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">tok</span><span class="p">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">spacy_de</span><span class="p">.</span><span class="n">tokenizer</span><span class="p">(</span><span class="n">text</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">tokenize_en</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="s">"""
    Tokenizes English text from a string into a list of strings (tokens)
    """</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">tok</span><span class="p">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">spacy_en</span><span class="p">.</span><span class="n">tokenizer</span><span class="p">(</span><span class="n">text</span><span class="p">)]</span>
</code></pre></div></div>

<p>TorchText‚Äôs <code class="language-plaintext highlighter-rouge">Field</code>s handle how data should be processed. You can read all of the possible arguments <a href="https://github.com/pytorch/text/blob/master/torchtext/data/field.py#L61">here</a>.</p>

<p>We set the <code class="language-plaintext highlighter-rouge">tokenize</code> argument to the correct tokenization function for each, with German being the <code class="language-plaintext highlighter-rouge">SRC</code> (source) field and English being the <code class="language-plaintext highlighter-rouge">TRG</code> (target) field. The field also appends the ‚Äústart of sequence‚Äù and ‚Äúend of sequence‚Äù tokens via the <code class="language-plaintext highlighter-rouge">init_token</code> and <code class="language-plaintext highlighter-rouge">eos_token</code> arguments, and converts all words to lowercase.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SRC</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">tokenize</span> <span class="o">=</span> <span class="n">tokenize_de</span><span class="p">,</span> 
            <span class="n">init_token</span> <span class="o">=</span> <span class="s">'&lt;sos&gt;'</span><span class="p">,</span> 
            <span class="n">eos_token</span> <span class="o">=</span> <span class="s">'&lt;eos&gt;'</span><span class="p">,</span> 
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>

<span class="n">TRG</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">tokenize</span> <span class="o">=</span> <span class="n">tokenize_en</span><span class="p">,</span> 
            <span class="n">init_token</span> <span class="o">=</span> <span class="s">'&lt;sos&gt;'</span><span class="p">,</span> 
            <span class="n">eos_token</span> <span class="o">=</span> <span class="s">'&lt;eos&gt;'</span><span class="p">,</span> 
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<p>Next, we download and load the train, validation and test data.</p>

<p>The dataset we‚Äôll be using is the <a href="https://github.com/multi30k/dataset">Multi30k dataset</a>. This is a dataset with ~30,000 parallel English, German and French sentences, each with ~12 words per sentence.</p>

<p><code class="language-plaintext highlighter-rouge">exts</code> specifies which languages to use as the source and target (source goes first) and <code class="language-plaintext highlighter-rouge">fields</code> specifies which field to use for the source and target.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">train_data</span><span class="p">,</span> <span class="n">valid_data</span><span class="p">,</span> <span class="n">test_data</span> <span class="o">=</span> <span class="n">Multi30k</span><span class="p">.</span><span class="n">splits</span><span class="p">(</span><span class="n">exts</span> <span class="o">=</span> <span class="p">(</span><span class="s">'.de'</span><span class="p">,</span> <span class="s">'.en'</span><span class="p">),</span> 
                                                    <span class="n">fields</span> <span class="o">=</span> <span class="p">(</span><span class="n">SRC</span><span class="p">,</span> <span class="n">TRG</span><span class="p">))</span>
</code></pre></div></div>

<p>We can double check that we‚Äôve loaded the right number of examples:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">f"Number of training examples: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">train_data</span><span class="p">.</span><span class="n">examples</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Number of validation examples: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_data</span><span class="p">.</span><span class="n">examples</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Number of testing examples: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">test_data</span><span class="p">.</span><span class="n">examples</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Number of training examples: 29000
Number of validation examples: 1014
Number of testing examples: 1000
</code></pre></div></div>

<p>We can also print out an example, making sure the source sentence is reversed:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">train_data</span><span class="p">.</span><span class="n">examples</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{'src': ['.', 'b√ºsche', 'vieler', 'n√§he', 'der', 'in', 'freien', 'im', 'sind', 'm√§nner', 'wei√üe', 'junge', 'zwei'], 'trg': ['two', 'young', ',', 'white', 'males', 'are', 'outside', 'near', 'many', 'bushes', '.']}
</code></pre></div></div>

<p>The period is at the beginning of the German (src) sentence, so looks good!</p>

<p>Next, we‚Äôll build the <em>vocabulary</em> for the source and target languages. The vocabulary is used to associate each unique token with an index (an integer) and this is used to build a one-hot encoding for each token (a vector of all zeros except for the position represented by the index, which is 1). The vocabularies of the source and target languages are distinct.</p>

<p>Using the <code class="language-plaintext highlighter-rouge">min_freq</code> argument, we only allow tokens that appear at least 2 times to appear in our vocabulary. Tokens that appear only once are converted into an <code class="language-plaintext highlighter-rouge">&lt;unk&gt;</code> (unknown) token.</p>

<p>It is important to note that your vocabulary should only be built from the training set and not the validation/test set. This prevents ‚Äúinformation leakage‚Äù into your model, giving you artifically inflated validation/test scores.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SRC</span><span class="p">.</span><span class="n">build_vocab</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">min_freq</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">TRG</span><span class="p">.</span><span class="n">build_vocab</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">min_freq</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">f"Unique tokens in source (de) vocabulary: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">SRC</span><span class="p">.</span><span class="n">vocab</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">f"Unique tokens in target (en) vocabulary: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">TRG</span><span class="p">.</span><span class="n">vocab</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unique tokens in source (de) vocabulary: 7855
Unique tokens in target (en) vocabulary: 5893
</code></pre></div></div>

<p>The final step of preparing the data is to create the iterators. These can be iterated on to return a batch of data which will have a <code class="language-plaintext highlighter-rouge">src</code> attribute (the PyTorch tensors containing a batch of numericalized source sentences) and a <code class="language-plaintext highlighter-rouge">trg</code> attribute (the PyTorch tensors containing a batch of numericalized target sentences). Numericalized is just a fancy way of saying they have been converted from a sequence of readable tokens to a sequence of corresponding indexes, using the vocabulary.</p>

<p>We also need to define a <code class="language-plaintext highlighter-rouge">torch.device</code>. This is used to tell TorchText to put the tensors on the GPU or not. We use the <code class="language-plaintext highlighter-rouge">torch.cuda.is_available()</code> function, which will return <code class="language-plaintext highlighter-rouge">True</code> if a GPU is detected on our computer. We pass this <code class="language-plaintext highlighter-rouge">device</code> to the iterator.</p>

<p>When we get a batch of examples using an iterator we need to make sure that all of the source sentences are padded to the same length, the same with the target sentences. Luckily, TorchText iterators handle this for us!</p>

<p>We use a <code class="language-plaintext highlighter-rouge">BucketIterator</code> instead of the standard <code class="language-plaintext highlighter-rouge">Iterator</code> as it creates batches in such a way that it minimizes the amount of padding in both the source and target sentences.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">device</span><span class="p">(</span><span class="s">'cuda'</span> <span class="k">if</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s">'cpu'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">128</span>

<span class="n">train_iterator</span><span class="p">,</span> <span class="n">valid_iterator</span><span class="p">,</span> <span class="n">test_iterator</span> <span class="o">=</span> <span class="n">BucketIterator</span><span class="p">.</span><span class="n">splits</span><span class="p">(</span>
    <span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">valid_data</span><span class="p">,</span> <span class="n">test_data</span><span class="p">),</span> 
    <span class="n">batch_size</span> <span class="o">=</span> <span class="n">BATCH_SIZE</span><span class="p">,</span> 
    <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="building-the-seq2seq-model">Building the Seq2Seq Model</h2>

<p>We‚Äôll be building our model in three parts. The encoder, the decoder and a seq2seq model that encapsulates the encoder and decoder and will provide a way to interface with each.</p>

<h3 id="encoder">Encoder</h3>

<p>First, the encoder, a 2 layer LSTM. The paper we are implementing uses a 4-layer LSTM, but in the interest of training time we cut this down to 2-layers. The concept of multi-layer RNNs is easy to expand from 2 to 4 layers.</p>

<p>For a multi-layer RNN, the input sentence, $X$, goes into the first (bottom) layer of the RNN and hidden states, $H={h_1, h_2, ‚Ä¶, h_T}$, output by this layer are used as inputs to the RNN in the layer above. Thus, representing each layer with a superscript, the hidden states in the first layer are given by:</p>

\[h_t^1 = \text{EncoderRNN}^1(x_t, h_{t-1}^1)\]

<p>The hidden states in the second layer are given by:</p>

\[h_t^2 = \text{EncoderRNN}^2(h_t^1, h_{t-1}^2)\]

<p>Using a multi-layer RNN also means we‚Äôll also need an initial hidden state as input per layer, $h_0^l$, and we will also output a context vector per layer, $z^l$.</p>

<p>Without going into too much detail about LSTMs (see <a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">this</a> blog post if you want to learn more about them), all we need to know is that they‚Äôre a type of RNN which instead of just taking in a hidden state and returning a new hidden state per time-step, also take in and return a <em>cell state</em>, $c_t$, per time-step.</p>

\[\begin{align*}
h_t &amp;= \text{RNN}(x_t, h_{t-1})\\
(h_t, c_t) &amp;= \text{LSTM}(x_t, (h_{t-1}, c_{t-1}))
\end{align*}\]

<p>You can just think of $c_t$ as another type of hidden state. Similar to $h_0^l$, $c_0^l$ will be initialized to a tensor of all zeros. Also, our context vector will now be both the final hidden state and the final cell state, i.e. $z^l = (h_T^l, c_T^l)$.</p>

<p>Extending our multi-layer equations to LSTMs, we get:</p>

\[\begin{align*}
(h_t^1, c_t^1) &amp;= \text{EncoderLSTM}^1(x_t, (h_{t-1}^1, c_{t-1}^1))\\
(h_t^2, c_t^2) &amp;= \text{EncoderLSTM}^2(h_t^1, (h_{t-1}^2, c_{t-1}^2))
\end{align*}\]

<p>Note how only our hidden state from the first layer is passed as input to the second layer, and not the cell state.</p>

<p>So our encoder looks something like this:</p>

<p><img src="https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@1.0/assets/img/blog/190828-seq2seq2.png" alt="seq2seq2" /></p>

<p>We create this in code by making an <code class="language-plaintext highlighter-rouge">Encoder</code> module, which requires we inherit from <code class="language-plaintext highlighter-rouge">torch.nn.Module</code> and use the <code class="language-plaintext highlighter-rouge">super().__init__()</code> as some boilerplate code. The encoder takes the following arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">input_dim</code> is the size/dimensionality of the one-hot vectors that will be input to the encoder. This is equal to the input (source) vocabulary size.</li>
  <li><code class="language-plaintext highlighter-rouge">emb_dim</code> is the dimensionality of the embedding layer. This layer converts the one-hot vectors into dense vectors with <code class="language-plaintext highlighter-rouge">emb_dim</code> dimensions.</li>
  <li><code class="language-plaintext highlighter-rouge">hid_dim</code> is the dimensionality of the hidden and cell states.</li>
  <li><code class="language-plaintext highlighter-rouge">n_layers</code> is the number of layers in the RNN.</li>
  <li><code class="language-plaintext highlighter-rouge">dropout</code> is the amount of dropout to use. This is a regularization parameter to prevent overfitting. Check out <a href="https://www.coursera.org/lecture/deep-neural-network/understanding-dropout-YaGbR">this</a> for more details about dropout.</li>
</ul>

<p>We aren‚Äôt going to discuss the embedding layer in these tutorials. All you need to know is that there is a step before the words - technically, the indexes of the words - are passed into the RNN, where the words are transformed into vectors. If you would like to know about word embeddings, I‚Äôd recommend these articles <a href="https://monkeylearn.com/blog/word-embeddings-transform-text-numbers/">1</a>, <a href="http://p.migdal.pl/2017/01/06/king-man-woman-queen-why.html">2</a>, <a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/">3</a>, <a href="http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/">4</a>.</p>

<p>The embedding layer is created using <code class="language-plaintext highlighter-rouge">nn.Embedding</code>, the LSTM with <code class="language-plaintext highlighter-rouge">nn.LSTM</code> and a dropout layer with <code class="language-plaintext highlighter-rouge">nn.Dropout</code>. Check the PyTorch <a href="https://pytorch.org/docs/stable/nn.html">documentation</a> for more about these.</p>

<p>One thing to note is that the <code class="language-plaintext highlighter-rouge">dropout</code> argument to the LSTM is how much dropout to apply between the layers of a multi-layer RNN, i.e. between the hidden states output from layer $l$ and those same hidden states being used for the input of layer $l+1$.</p>

<p>In the <code class="language-plaintext highlighter-rouge">forward</code> method, we pass in the source sentence, $X$, which is converted into dense vectors using the <code class="language-plaintext highlighter-rouge">embedding</code> layer, and then dropout is applied. These embeddings are then passed into the RNN. As we pass a whole sequence to the RNN, it will automatically do the recurrent calculation of the hidden states over the whole sequence for us! You may notice that we do not pass an initial hidden or cell state to the RNN. This is because, as noted in the <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.LSTM">documentation</a>, that if no hidden/cell state is passed to the RNN, it will automatically create an initial hidden/cell state as a tensor of all zeros.</p>

<p>The RNN returns: <code class="language-plaintext highlighter-rouge">outputs</code> (the top-layer hidden state for each time-step), <code class="language-plaintext highlighter-rouge">hidden</code> (the final hidden state for each layer, $h_T$, stacked on top of each other) and <code class="language-plaintext highlighter-rouge">cell</code> (the final cell state for each layer, $c_T$, stacked on top of each other).</p>

<p>As we only need the final hidden and cell states (to make our context vector), <code class="language-plaintext highlighter-rouge">forward</code> only returns <code class="language-plaintext highlighter-rouge">hidden</code> and <code class="language-plaintext highlighter-rouge">cell</code>.</p>

<p>The sizes of each of the tensors is left as comments in the code. In this implementation <code class="language-plaintext highlighter-rouge">n_directions</code> will always be 1, however note that bidirectional RNNs (covered in tutorial 3) will have <code class="language-plaintext highlighter-rouge">n_directions</code> as 2.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Encoder</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">hid_dim</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">input_dim</span> <span class="o">=</span> <span class="n">input_dim</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">emb_dim</span> <span class="o">=</span> <span class="n">emb_dim</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">hid_dim</span> <span class="o">=</span> <span class="n">hid_dim</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n_layers</span> <span class="o">=</span> <span class="n">n_layers</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">dropout</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">hid_dim</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">,</span> <span class="n">dropout</span> <span class="o">=</span> <span class="n">dropout</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">dropout</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        
        <span class="c1">#src = [src sent len, batch size]
</span>        
        <span class="n">embedded</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">dropout</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">embedding</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
        
        <span class="c1">#embedded = [src sent len, batch size, emb dim]
</span>        
        <span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">embedded</span><span class="p">)</span>
        
        <span class="c1">#outputs = [src sent len, batch size, hid dim * n directions]
</span>        <span class="c1">#hidden = [n layers * n directions, batch size, hid dim]
</span>        <span class="c1">#cell = [n layers * n directions, batch size, hid dim]
</span>        
        <span class="c1">#outputs are always from the top hidden layer
</span>        
        <span class="k">return</span> <span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span>

</code></pre></div></div>

<h3 id="decoder">Decoder</h3>

<p>Next, we‚Äôll build our decoder, which will also be a 2-layer (4 in the paper) LSTM.</p>

<p><img src="https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@1.0/assets/img/blog/190828-seq2seq3.png" alt="seq2seq3" /></p>

<p>The <code class="language-plaintext highlighter-rouge">Decoder</code> class does a single step of decoding. The first layer will receive a hidden and cell state from the previous time-step, $(s_{t-1}^1, c_{t-1}^1)$, and feed it through the LSTM with the current token, $y_t$, to produce a new hidden and cell state, $(s_t^1, c_t^1)$. The subsequent layers will use the hidden state from the layer below, $s_t^{l-1}$, and the previous hidden and cell states from their layer, $(s_{t-1}^l, c_{t-1}^l)$. This provides equations very similar to those in the encoder.</p>

\[\begin{align*}
(s_t^1, c_t^1) = \text{DecoderLSTM}^1(y_t, (s_{t-1}^1, c_{t-1}^1))\\
(s_t^2, c_t^2) = \text{DecoderLSTM}^2(s_t^1, (s_{t-1}^2, c_{t-1}^2))
\end{align*}\]

<p>Remember that the initial hidden and cell states to our decoder are our context vectors, which are the final hidden and cell states of our encoder from the same layer, i.e. $(s_0^l,c_0^l)=z^l=(h_T^l,c_T^l)$.</p>

<p>We then pass the hidden state from the top layer of the RNN, $s_t^L$, through a linear layer, $f$, to make a prediction of what the next token in the target (output) sequence should be, $\hat{y}_{t+1}$.</p>

\[\hat{y}_{t+1} = f(s_t^L)\]

<p>The arguments and initialization are similar to the <code class="language-plaintext highlighter-rouge">Encoder</code> class, except we now have an <code class="language-plaintext highlighter-rouge">output_dim</code> which is the size of the one-hot vectors that will be input to the decoder. These are equal to the vocabulary size of the output/target. There is also the addition of the <code class="language-plaintext highlighter-rouge">Linear</code> layer, used to make the predictions from the top layer hidden state.</p>

<p>Within the <code class="language-plaintext highlighter-rouge">forward</code> method, we accept a batch of input tokens, previous hidden states and previous cell states. We <code class="language-plaintext highlighter-rouge">unsqueeze</code> the input tokens to add a sentence length dimension of 1. Then, similar to the encoder, we pass through an embedding layer and apply dropout. This batch of embedded tokens is then passed into the RNN with the previous hidden and cell states. This produces an <code class="language-plaintext highlighter-rouge">output</code> (hidden state from the top layer of the RNN), a new <code class="language-plaintext highlighter-rouge">hidden</code> state (one for each layer, stacked on top of each other) and a new <code class="language-plaintext highlighter-rouge">cell</code> state (also one per layer, stacked on top of each other). We then pass the <code class="language-plaintext highlighter-rouge">output</code> (after getting rid of the sentence length dimension) through the linear layer to receive our <code class="language-plaintext highlighter-rouge">prediction</code>. We then return the <code class="language-plaintext highlighter-rouge">prediction</code>, the new <code class="language-plaintext highlighter-rouge">hidden</code> state and the new <code class="language-plaintext highlighter-rouge">cell</code> state.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Decoder</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">hid_dim</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">,</span> <span class="n">dropout</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">emb_dim</span> <span class="o">=</span> <span class="n">emb_dim</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">hid_dim</span> <span class="o">=</span> <span class="n">hid_dim</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">output_dim</span> <span class="o">=</span> <span class="n">output_dim</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">n_layers</span> <span class="o">=</span> <span class="n">n_layers</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">dropout</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">output_dim</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">hid_dim</span><span class="p">,</span> <span class="n">n_layers</span><span class="p">,</span> <span class="n">dropout</span> <span class="o">=</span> <span class="n">dropout</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">out</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hid_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">dropout</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span><span class="p">):</span>
        
        <span class="c1">#input = [batch size]
</span>        <span class="c1">#hidden = [n layers * n directions, batch size, hid dim]
</span>        <span class="c1">#cell = [n layers * n directions, batch size, hid dim]
</span>        
        <span class="c1">#n directions in the decoder will both always be 1, therefore:
</span>        <span class="c1">#hidden = [n layers, batch size, hid dim]
</span>        <span class="c1">#context = [n layers, batch size, hid dim]
</span>        
        <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1">#input = [1, batch size]
</span>        
        <span class="n">embedded</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">dropout</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">embedding</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>
        
        <span class="c1">#embedded = [1, batch size, emb dim]
</span>                
        <span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">embedded</span><span class="p">,</span> <span class="p">(</span><span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span><span class="p">))</span>
        
        <span class="c1">#output = [sent len, batch size, hid dim * n directions]
</span>        <span class="c1">#hidden = [n layers * n directions, batch size, hid dim]
</span>        <span class="c1">#cell = [n layers * n directions, batch size, hid dim]
</span>        
        <span class="c1">#sent len and n directions will always be 1 in the decoder, therefore:
</span>        <span class="c1">#output = [1, batch size, hid dim]
</span>        <span class="c1">#hidden = [n layers, batch size, hid dim]
</span>        <span class="c1">#cell = [n layers, batch size, hid dim]
</span>        
        <span class="n">prediction</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">out</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="c1">#prediction = [batch size, output dim]
</span>        
        <span class="k">return</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span>
</code></pre></div></div>

<h3 id="seq2seq">Seq2Seq</h3>

<p>For the final part of the implemenetation, we‚Äôll implement the seq2seq model. This will handle:</p>

<ul>
  <li>receiving the input/source sentence</li>
  <li>using the encoder to produce the context vectors</li>
  <li>using the decoder to produce the predicted output/target sentence</li>
</ul>

<p>Our full model will look like this:</p>

<p><img src="https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@1.0/assets/img/blog/190828-seq2seq4.png" alt="seq2seq4" /></p>

<p>The <code class="language-plaintext highlighter-rouge">Seq2Seq</code> model takes in an <code class="language-plaintext highlighter-rouge">Encoder</code>, <code class="language-plaintext highlighter-rouge">Decoder</code>, and a <code class="language-plaintext highlighter-rouge">device</code> (used to place tensors on the GPU, if it exists).</p>

<p>For this implementation, we have to ensure that the number of layers and the hidden (and cell) dimensions are equal in the <code class="language-plaintext highlighter-rouge">Encoder</code> and <code class="language-plaintext highlighter-rouge">Decoder</code>. This is not always the case, you do not necessarily need the same number of layers or the same hidden dimension sizes in a sequence-to-sequence model. However, if you do something like having a different number of layers you will need to make decisions about how this is handled. For example, if your encoder has 2 layers and your decoder only has 1, how is this handled? Do you average the two context vectors output by the decoder? Do you pass both through a linear layer? Do you only use the context vector from the highest layer? Etc.</p>

<p>Our <code class="language-plaintext highlighter-rouge">forward</code> method takes the source sentence, target sentence and a teacher-forcing ratio. The teacher forcing ratio is used when training our model. When decoding, at each time-step we will predict what the next token in the target sequence will be from the previous tokens decoded, $\hat{y}_{t+1}=f(s_t^L)$. With probability equal to the teaching forcing ratio (<code class="language-plaintext highlighter-rouge">teacher_forcing_ratio</code>) we will use the actual ground-truth next token in the sequence as the input to the decoder during the next time-step. However, with probability <code class="language-plaintext highlighter-rouge">1 - teacher_forcing_ratio</code>, we will use the token that the model predicted as the next input to the model, even if it doesn‚Äôt match the actual next token in the sequence.</p>

<p>The first thing we do in the <code class="language-plaintext highlighter-rouge">forward</code> method is to create an <code class="language-plaintext highlighter-rouge">outputs</code> tensor that will store all of our predictions, $\hat{Y}$.</p>

<p>We then feed the input/source sentence, $X$/<code class="language-plaintext highlighter-rouge">src</code>, into the encoder and receive out final hidden and cell states.</p>

<p>The first input to the decoder is the start of sequence (<code class="language-plaintext highlighter-rouge">&lt;sos&gt;</code>) token. As our <code class="language-plaintext highlighter-rouge">trg</code> tensor already has the <code class="language-plaintext highlighter-rouge">&lt;sos&gt;</code> token appended (all the way back when we defined the <code class="language-plaintext highlighter-rouge">init_token</code> in our <code class="language-plaintext highlighter-rouge">TRG</code> field) we get our $y_1$ by slicing into it. We know how long our target sentences should be (<code class="language-plaintext highlighter-rouge">max_len</code>), so we loop that many times. During each iteration of the loop, we:</p>

<ul>
  <li>pass the input, previous hidden and previous cell states ($y_t, s_{t-1}, c_{t-1}$) into the decoder</li>
  <li>receive a prediction, next hidden state and next cell state ($\hat{y}<em>{t+1}, s</em>{t}, c_{t}$) from the decoder</li>
  <li>place our prediction, $\hat{y}_{t+1}$/<code class="language-plaintext highlighter-rouge">output</code> in our tensor of predictions, $\hat{Y}$/<code class="language-plaintext highlighter-rouge">outputs</code></li>
  <li>decide if we are going to ‚Äúteacher force‚Äù or not
    <ul>
      <li>if we do, the next <code class="language-plaintext highlighter-rouge">input</code> is the ground-truth next token in the sequence, $y_{t+1}$/<code class="language-plaintext highlighter-rouge">trg[t]</code></li>
      <li>if we don‚Äôt, the next <code class="language-plaintext highlighter-rouge">input</code> is the predicted next token in the sequence, $\hat{y}_{t+1}$/<code class="language-plaintext highlighter-rouge">top1</code></li>
    </ul>
  </li>
</ul>

<p>Once we‚Äôve made all of our predictions, we return our tensor full of predictions, $\hat{Y}$/<code class="language-plaintext highlighter-rouge">outputs</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Seq2Seq</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoder</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="p">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">encoder</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="n">decoder</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        
        <span class="k">assert</span> <span class="n">encoder</span><span class="p">.</span><span class="n">hid_dim</span> <span class="o">==</span> <span class="n">decoder</span><span class="p">.</span><span class="n">hid_dim</span><span class="p">,</span> \
            <span class="s">"Hidden dimensions of encoder and decoder must be equal!"</span>
        <span class="k">assert</span> <span class="n">encoder</span><span class="p">.</span><span class="n">n_layers</span> <span class="o">==</span> <span class="n">decoder</span><span class="p">.</span><span class="n">n_layers</span><span class="p">,</span> \
            <span class="s">"Encoder and decoder must have equal number of layers!"</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">trg</span><span class="p">,</span> <span class="n">teacher_forcing_ratio</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">):</span>
        
        <span class="c1">#src = [src sent len, batch size]
</span>        <span class="c1">#trg = [trg sent len, batch size]
</span>        <span class="c1">#teacher_forcing_ratio is probability to use teacher forcing
</span>        <span class="c1">#e.g. if teacher_forcing_ratio is 0.75 we use ground-truth inputs 75% of the time
</span>        
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">trg</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="n">trg</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">trg_vocab_size</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">decoder</span><span class="p">.</span><span class="n">output_dim</span>
        
        <span class="c1">#tensor to store decoder outputs
</span>        <span class="n">outputs</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">trg_vocab_size</span><span class="p">).</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">device</span><span class="p">)</span>
        
        <span class="c1">#last hidden state of the encoder is used as the initial hidden state of the decoder
</span>        <span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        
        <span class="c1">#first input to the decoder is the &lt;sos&gt; tokens
</span>        <span class="nb">input</span> <span class="o">=</span> <span class="n">trg</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_len</span><span class="p">):</span>
            
            <span class="n">output</span><span class="p">,</span> <span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">decoder</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
            <span class="n">outputs</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>
            <span class="n">teacher_force</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">teacher_forcing_ratio</span>
            <span class="n">top1</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="nb">input</span> <span class="o">=</span> <span class="p">(</span><span class="n">trg</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="k">if</span> <span class="n">teacher_force</span> <span class="k">else</span> <span class="n">top1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">outputs</span>

</code></pre></div></div>

<h1 id="training-the-seq2seq-model">Training the Seq2Seq Model</h1>

<p>Now we have our model implemented, we can begin training it.</p>

<p>First, we‚Äôll initialize our model. As mentioned before, the input and output dimensions are defined by the size of the vocabulary. The embedding dimesions and dropout for the encoder and decoder can be different, but the number of layers and the size of the hidden/cell states must be the same.</p>

<p>We then define the encoder, decoder and then our Seq2Seq model, which we place on the <code class="language-plaintext highlighter-rouge">device</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">INPUT_DIM</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SRC</span><span class="p">.</span><span class="n">vocab</span><span class="p">)</span>
<span class="n">OUTPUT_DIM</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TRG</span><span class="p">.</span><span class="n">vocab</span><span class="p">)</span>
<span class="n">ENC_EMB_DIM</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">DEC_EMB_DIM</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">HID_DIM</span> <span class="o">=</span> <span class="mi">512</span>
<span class="n">N_LAYERS</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">ENC_DROPOUT</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">DEC_DROPOUT</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">enc</span> <span class="o">=</span> <span class="n">Encoder</span><span class="p">(</span><span class="n">INPUT_DIM</span><span class="p">,</span> <span class="n">ENC_EMB_DIM</span><span class="p">,</span> <span class="n">HID_DIM</span><span class="p">,</span> <span class="n">N_LAYERS</span><span class="p">,</span> <span class="n">ENC_DROPOUT</span><span class="p">)</span>
<span class="n">dec</span> <span class="o">=</span> <span class="n">Decoder</span><span class="p">(</span><span class="n">OUTPUT_DIM</span><span class="p">,</span> <span class="n">DEC_EMB_DIM</span><span class="p">,</span> <span class="n">HID_DIM</span><span class="p">,</span> <span class="n">N_LAYERS</span><span class="p">,</span> <span class="n">DEC_DROPOUT</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Seq2Seq</span><span class="p">(</span><span class="n">enc</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="n">device</span><span class="p">).</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

</code></pre></div></div>

<p>Next up is initializing the weights of our model. In the paper they state they initialize all weights from a uniform distribution between -0.08 and +0.08, i.e. $\mathcal{U}(-0.08, 0.08)$.</p>

<p>We initialize weights in PyTorch by creating a function which we <code class="language-plaintext highlighter-rouge">apply</code> to our model. When using <code class="language-plaintext highlighter-rouge">apply</code>, the <code class="language-plaintext highlighter-rouge">init_weights</code> function will be called on every module and sub-module within our model. For each module we loop through all of the parameters and sample them from a uniform distribution with <code class="language-plaintext highlighter-rouge">nn.init.uniform_</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">init_weights</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">m</span><span class="p">.</span><span class="n">named_parameters</span><span class="p">():</span>
        <span class="n">nn</span><span class="p">.</span><span class="n">init</span><span class="p">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">0.08</span><span class="p">)</span>
        
<span class="n">model</span><span class="p">.</span><span class="nb">apply</span><span class="p">(</span><span class="n">init_weights</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Seq2Seq(
  (encoder): Encoder(
    (embedding): Embedding(7855, 256)
    (rnn): LSTM(256, 512, num_layers=2, dropout=0.5)
    (dropout): Dropout(p=0.5)
  )
  (decoder): Decoder(
    (embedding): Embedding(5893, 256)
    (rnn): LSTM(256, 512, num_layers=2, dropout=0.5)
    (out): Linear(in_features=512, out_features=5893, bias=True)
    (dropout): Dropout(p=0.5)
  )
)

</code></pre></div></div>

<p>We also define a function that will calculate the number of trainable parameters in the model.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">count_parameters</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">numel</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">model</span><span class="p">.</span><span class="n">parameters</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="p">.</span><span class="n">requires_grad</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">f'The model has </span><span class="si">{</span><span class="n">count_parameters</span><span class="p">(</span><span class="n">model</span><span class="p">):,</span><span class="si">}</span><span class="s"> trainable parameters'</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The model has 13,899,013 trainable parameters

</code></pre></div></div>

<p>We define our optimizer, which we use to update our parameters in the training loop. Check out <a href="http://ruder.io/optimizing-gradient-descent/">this</a> post for information about different optimizers. Here, we‚Äôll use Adam.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="p">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">parameters</span><span class="p">())</span>

</code></pre></div></div>

<p>Next, we define our loss function. The <code class="language-plaintext highlighter-rouge">CrossEntropyLoss</code> function calculates both the log softmax as well as the negative log-likelihood of our predictions.</p>

<p>Our loss function calculates the average loss per token, however by passing the index of the <code class="language-plaintext highlighter-rouge">&lt;pad&gt;</code> token as the <code class="language-plaintext highlighter-rouge">ignore_index</code> argument we ignore the loss whenever the target token is a padding token.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PAD_IDX</span> <span class="o">=</span> <span class="n">TRG</span><span class="p">.</span><span class="n">vocab</span><span class="p">.</span><span class="n">stoi</span><span class="p">[</span><span class="s">'&lt;pad&gt;'</span><span class="p">]</span>

<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">CrossEntropyLoss</span><span class="p">(</span><span class="n">ignore_index</span> <span class="o">=</span> <span class="n">PAD_IDX</span><span class="p">)</span>

</code></pre></div></div>

<p>Next, we‚Äôll define our training loop.</p>

<p>First, we‚Äôll set the model into ‚Äútraining mode‚Äù with <code class="language-plaintext highlighter-rouge">model.train()</code>. This will turn on dropout (and batch normalization, which we aren‚Äôt using) and then iterate through our data iterator.</p>

<p>At each iteration:</p>

<ul>
  <li>get the source and target sentences from the batch, $X$ and $Y$</li>
  <li>zero the gradients calculated from the last batch</li>
  <li>feed the source and target into the model to get the output, $\hat{Y}$</li>
  <li>as the loss function only works on 2d inputs with 1d targets we need to flatten each of them with <code class="language-plaintext highlighter-rouge">.view</code>
    <ul>
      <li>we also don‚Äôt want to measure the loss of the <code class="language-plaintext highlighter-rouge">&lt;sos&gt;</code> token, hence we slice off the first column of the output and target tensors</li>
    </ul>
  </li>
  <li>calculate the gradients with <code class="language-plaintext highlighter-rouge">loss.backward()</code></li>
  <li>clip the gradients to prevent them from exploding (a common issue in RNNs)</li>
  <li>update the parameters of our model by doing an optimizer step</li>
  <li>sum the loss value to a running total</li>
</ul>

<p>Finally, we return the loss that is averaged over all batches.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">clip</span><span class="p">):</span>
    
    <span class="n">model</span><span class="p">.</span><span class="n">train</span><span class="p">()</span>
    
    <span class="n">epoch_loss</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
        
        <span class="n">src</span> <span class="o">=</span> <span class="n">batch</span><span class="p">.</span><span class="n">src</span>
        <span class="n">trg</span> <span class="o">=</span> <span class="n">batch</span><span class="p">.</span><span class="n">trg</span>
        
        <span class="n">optimizer</span><span class="p">.</span><span class="n">zero_grad</span><span class="p">()</span>
        
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">trg</span><span class="p">)</span>
        
        <span class="c1">#trg = [trg sent len, batch size]
</span>        <span class="c1">#output = [trg sent len, batch size, output dim]
</span>        
        <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">:].</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">trg</span> <span class="o">=</span> <span class="n">trg</span><span class="p">[</span><span class="mi">1</span><span class="p">:].</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1">#trg = [(trg sent len - 1) * batch size]
</span>        <span class="c1">#output = [(trg sent len - 1) * batch size, output dim]
</span>        
        <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">trg</span><span class="p">)</span>
        
        <span class="n">loss</span><span class="p">.</span><span class="n">backward</span><span class="p">()</span>
        
        <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">utils</span><span class="p">.</span><span class="n">clip_grad_norm_</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">clip</span><span class="p">)</span>
        
        <span class="n">optimizer</span><span class="p">.</span><span class="n">step</span><span class="p">()</span>
        
        <span class="n">epoch_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="p">.</span><span class="n">item</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">epoch_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>

</code></pre></div></div>

<p>Our evaluation loop is similar to our training loop, however as we aren‚Äôt updating any parameters we don‚Äôt need to pass an optimizer or a clip value.</p>

<p>We must remember to set the model to evaluation mode with <code class="language-plaintext highlighter-rouge">model.eval()</code>. This will turn off dropout (and batch normalization, if used).</p>

<p>We use the <code class="language-plaintext highlighter-rouge">with torch.no_grad()</code> block to ensure no gradients are calculated within the block. This reduces memory consumption and speeds things up.</p>

<p>The iteration loop is similar (without the parameter updates), however we must ensure we turn teacher forcing off for evaluation. This will cause the model to only use it‚Äôs own predictions to make further predictions within a sentence, which mirrors how it would be used in deployment.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">criterion</span><span class="p">):</span>
    
    <span class="n">model</span><span class="p">.</span><span class="nb">eval</span><span class="p">()</span>
    
    <span class="n">epoch_loss</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="n">no_grad</span><span class="p">():</span>
    
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>

            <span class="n">src</span> <span class="o">=</span> <span class="n">batch</span><span class="p">.</span><span class="n">src</span>
            <span class="n">trg</span> <span class="o">=</span> <span class="n">batch</span><span class="p">.</span><span class="n">trg</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">trg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#turn off teacher forcing
</span>
            <span class="c1">#trg = [trg sent len, batch size]
</span>            <span class="c1">#output = [trg sent len, batch size, output dim]
</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">:].</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">trg</span> <span class="o">=</span> <span class="n">trg</span><span class="p">[</span><span class="mi">1</span><span class="p">:].</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1">#trg = [(trg sent len - 1) * batch size]
</span>            <span class="c1">#output = [(trg sent len - 1) * batch size, output dim]
</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">trg</span><span class="p">)</span>
            
            <span class="n">epoch_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="p">.</span><span class="n">item</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">epoch_loss</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>

</code></pre></div></div>

<p>Next, we‚Äôll create a function that we‚Äôll use to tell us how long an epoch takes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">epoch_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">):</span>
    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
    <span class="n">elapsed_mins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elapsed_time</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">elapsed_secs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elapsed_time</span> <span class="o">-</span> <span class="p">(</span><span class="n">elapsed_mins</span> <span class="o">*</span> <span class="mi">60</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">elapsed_mins</span><span class="p">,</span> <span class="n">elapsed_secs</span>

</code></pre></div></div>

<p>We can finally start training our model!</p>

<p>At each epoch, we‚Äôll be checking if our model has achieved the best validation loss so far. If it has, we‚Äôll update our best validation loss and save the parameters of our model (called <code class="language-plaintext highlighter-rouge">state_dict</code> in PyTorch). Then, when we come to test our model, we‚Äôll use the saved parameters used to achieve the best validation loss.</p>

<p>We‚Äôll be printing out both the loss and the perplexity at each epoch. It is easier to see a change in perplexity than a change in loss as the numbers are much bigger.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N_EPOCHS</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">CLIP</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">best_valid_loss</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>

<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_EPOCHS</span><span class="p">):</span>
    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">train_loss</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">train_iterator</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">CLIP</span><span class="p">)</span>
    <span class="n">valid_loss</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">valid_iterator</span><span class="p">,</span> <span class="n">criterion</span><span class="p">)</span>
    
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">epoch_mins</span><span class="p">,</span> <span class="n">epoch_secs</span> <span class="o">=</span> <span class="n">epoch_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">valid_loss</span> <span class="o">&lt;</span> <span class="n">best_valid_loss</span><span class="p">:</span>
        <span class="n">best_valid_loss</span> <span class="o">=</span> <span class="n">valid_loss</span>
        <span class="n">torch</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s">'tut1-model.pt'</span><span class="p">)</span>
    
    <span class="k">print</span><span class="p">(</span><span class="s">f'Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="mi">02</span><span class="si">}</span><span class="s"> | Time: </span><span class="si">{</span><span class="n">epoch_mins</span><span class="si">}</span><span class="s">m </span><span class="si">{</span><span class="n">epoch_secs</span><span class="si">}</span><span class="s">s'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">f'</span><span class="se">\t</span><span class="s">Train Loss: </span><span class="si">{</span><span class="n">train_loss</span><span class="p">:.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="s"> | Train PPL: </span><span class="si">{</span><span class="n">math</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="n">train_loss</span><span class="p">):</span><span class="mf">7.3</span><span class="n">f</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">f'</span><span class="se">\t</span><span class="s"> Val. Loss: </span><span class="si">{</span><span class="n">valid_loss</span><span class="p">:.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="s"> |  Val. PPL: </span><span class="si">{</span><span class="n">math</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="n">valid_loss</span><span class="p">):</span><span class="mf">7.3</span><span class="n">f</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Epoch: 01 | Time: 0m 24s
	Train Loss: 5.065 | Train PPL: 158.383
	 Val. Loss: 4.971 |  Val. PPL: 144.200
Epoch: 02 | Time: 0m 24s
	Train Loss: 4.543 | Train PPL:  93.968
	 Val. Loss: 4.928 |  Val. PPL: 138.160
Epoch: 03 | Time: 0m 24s
	Train Loss: 4.263 | Train PPL:  71.039
	 Val. Loss: 4.650 |  Val. PPL: 104.627
Epoch: 04 | Time: 0m 24s
	Train Loss: 4.039 | Train PPL:  56.745
	 Val. Loss: 4.554 |  Val. PPL:  95.007
Epoch: 05 | Time: 0m 23s
	Train Loss: 3.889 | Train PPL:  48.884
	 Val. Loss: 4.495 |  Val. PPL:  89.537
Epoch: 06 | Time: 0m 24s
	Train Loss: 3.773 | Train PPL:  43.514
	 Val. Loss: 4.390 |  Val. PPL:  80.644
Epoch: 07 | Time: 0m 23s
	Train Loss: 3.668 | Train PPL:  39.164
	 Val. Loss: 4.246 |  Val. PPL:  69.815
Epoch: 08 | Time: 0m 23s
	Train Loss: 3.555 | Train PPL:  34.990
	 Val. Loss: 4.235 |  Val. PPL:  69.030
Epoch: 09 | Time: 0m 23s
	Train Loss: 3.445 | Train PPL:  31.351
	 Val. Loss: 4.142 |  Val. PPL:  62.907
Epoch: 10 | Time: 0m 24s
	Train Loss: 3.370 | Train PPL:  29.074
	 Val. Loss: 4.145 |  Val. PPL:  63.089

</code></pre></div></div>

<p>We‚Äôll load the parameters (<code class="language-plaintext highlighter-rouge">state_dict</code>) that gave our model the best validation loss and run it the model on the test set.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">model</span><span class="p">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">'tut1-model.pt'</span><span class="p">))</span>

<span class="n">test_loss</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">test_iterator</span><span class="p">,</span> <span class="n">criterion</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">f'| Test Loss: </span><span class="si">{</span><span class="n">test_loss</span><span class="p">:.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="s"> | Test PPL: </span><span class="si">{</span><span class="n">math</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="n">test_loss</span><span class="p">):</span><span class="mf">7.3</span><span class="n">f</span><span class="si">}</span><span class="s"> |'</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| Test Loss: 4.178 | Test PPL:  65.215 |

</code></pre></div></div>

<p>In the following notebook we‚Äôll implement a model that achieves improved test perplexity, but only uses a single layer in the encoder and the decoder.</p>
:ET