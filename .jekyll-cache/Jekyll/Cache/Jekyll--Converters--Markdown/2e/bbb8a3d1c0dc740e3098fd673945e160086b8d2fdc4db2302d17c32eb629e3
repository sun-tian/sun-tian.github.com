I"~e<h1 id="如何实现一个promise"><a href="https://blog.fundebug.com/2017/05/25/arrow-function-for-beginner/"><strong>如何实现一个Promise</strong></a></h1>

<h2 id="引言">引言</h2>

<p><code class="language-plaintext highlighter-rouge">Promise</code>出现解决了js中的回调地狱的问题，使代码更简洁，是ES6中的规范和重要特性。它的使用很简单，但你知道它是怎么样实现的吗~~
 现在我们就来看一下Promise究竟是怎么样实现的😄</p>

<ul>
  <li><strong>promise规范</strong>
 Promise规范是Promise函数中需要遵循的规则， ES6中使用的Promise，它就是遵循<a href="https://promisesaplus.com/">Promise/A+规范</a>的。
 既然是有规则可循的，那我们根据规则来一步步实现<code class="language-plaintext highlighter-rouge">Promise</code>。</li>
</ul>

<h2 id="1创建promise类">1.创建Promise类</h2>

<p>看一下<code class="language-plaintext highlighter-rouge">Promise</code>是如何使用的</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    const promise = new Promise((resolve, reject) =&gt; {
        try {
            resolve('123');
        } catch(err) {
            reject('error');
        }
    });
    
    promise
    .then((msg) =&gt; {
        console.log(msg)
    })
复制代码
</code></pre></div></div>

<ul>
  <li>首先它是一个<strong>构造方法</strong>，并且接收一个<code class="language-plaintext highlighter-rouge">function</code>作为参数，
 而这个<code class="language-plaintext highlighter-rouge">function</code>中有<code class="language-plaintext highlighter-rouge">resolve</code>和<code class="language-plaintext highlighter-rouge">reject</code>两个方法。<code class="language-plaintext highlighter-rouge">resolve</code>代表成功后返回的值，<code class="language-plaintext highlighter-rouge">reject</code>代表拒绝返回的原因</li>
</ul>

<p>根据<code class="language-plaintext highlighter-rouge">Promise</code>的使用来创建一个叫<code class="language-plaintext highlighter-rouge">MyPromise</code>的类</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /**
     *  @params {function} callback 需要执行的业务方法
     */
    class MyPromise {
        // 构造方法接收一个function
        constructor(callback) {
            callback(this.resolve, this.reject); // 调用此function
        }
        resolve = (value) =&gt; {} // callback中执行的resolve方法
        reject = (reason) =&gt; {} // callback中执行的reject方法
    }
    
    // 测试
    var test = new MyPromise((resolve, reject) =&gt; {
        console.log('my promise is running!');
    }) // 打印出 my promise is running!
复制代码
</code></pre></div></div>

<h2 id="2三种状态">2.三种状态</h2>

<p>现在我们创建的类已经可以执行传入的方法了，但是它传入的<code class="language-plaintext highlighter-rouge">resolve</code>和<code class="language-plaintext highlighter-rouge">reject</code>方法是有什么用的呢？
 我们接着看<a href="https://promisesaplus.com/">Promise规范</a></p>

<p><img src="https://user-gold-cdn.xitu.io/2019/11/21/16e8d3e468224e0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<ul>
  <li>根据规范可知<code class="language-plaintext highlighter-rouge">Promise</code>有三种状态 <code class="language-plaintext highlighter-rouge">pending</code>（等待），<code class="language-plaintext highlighter-rouge">fulfilled</code>（完成），<code class="language-plaintext highlighter-rouge">rejected</code>（拒绝）。</li>
  <li>当状态为<code class="language-plaintext highlighter-rouge">pending</code>时，Promise可以变为<code class="language-plaintext highlighter-rouge">fulfilled</code>或<code class="language-plaintext highlighter-rouge">rejected</code>状态</li>
  <li>当状态为<code class="language-plaintext highlighter-rouge">fulfilled</code>时，Promise不能改变其状态；必须有值且不能改变</li>
  <li>当状态为<code class="language-plaintext highlighter-rouge">rejected</code>时，Promise不能改变其状态；必须有拒绝的原因且不能改变</li>
</ul>

<p>根据<code class="language-plaintext highlighter-rouge">Promise</code>规则，接着写刚刚创建的类：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    const stateArr = ['pending', 'fulfilled', 'rejected']; // 三种状态
    /**
     *  @params {function} callback 需要执行的业务方法
     */
    class MyPromise {
        constructor(callback) {
            this.state = stateArr[0]; // 当前状态
            this.value = null; // 完成时的返回值
            this.reason = null; // 失败原因
            
            callback(this.resolve, this.reject); // 调用此function
        }
        
        // callback中执行的resolve方法
        resolve = (value) =&gt; {
            // 判断状态是否需要是pending
            if (this.state === stateArr[0]) {
               this.state = stateArr[1]; // 更新状态为 fulfilled
               this.value = value; // 写入最终的返回值
            }
        }
        
        // callback中执行的reject方法
        reject = (reason) =&gt; {
            // 判断状态是否需要是pending
            if (this.state === stateArr[0]) {
               this.state = stateArr[2]; // 更新状态为 rejected
               this.reason = reason; // 写入拒绝的原因
            }
        } 
    }
复制代码
</code></pre></div></div>

<p>测试一下：</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/11/22/16e91fef6ecec66e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<p>可以看到，调用<code class="language-plaintext highlighter-rouge">resolve</code>后，状态变为<strong>fulfilled</strong>，再调用<code class="language-plaintext highlighter-rouge">reject</code>时，状态和值都不会改变，这样符合Promise规范~~</p>

<h2 id="3then方法">3.then方法</h2>

<p>我们的<code class="language-plaintext highlighter-rouge">MyPromise</code>写到这里，他已经可以实现更新状态和传值了，但是它的值怎么样输出给我们的业务呢？
 由<code class="language-plaintext highlighter-rouge">Promise</code>的使用可以看到，它是通过<code class="language-plaintext highlighter-rouge">then</code>方法来输出值的。<code class="language-plaintext highlighter-rouge">then</code>是是一个必要的方法，看一下<code class="language-plaintext highlighter-rouge">then</code>的规范：</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/11/22/16e920775a740a45?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<ul>
  <li>promise必须提供一个<code class="language-plaintext highlighter-rouge">then</code>方法去访问他的当前或最终的值或原因</li>
  <li>promise中<code class="language-plaintext highlighter-rouge">then</code>方法接收两个参数 <code class="language-plaintext highlighter-rouge">onFulilled</code>和<code class="language-plaintext highlighter-rouge">onRejected</code></li>
</ul>

<p>下面是关于<code class="language-plaintext highlighter-rouge">onFulilled</code>和<code class="language-plaintext highlighter-rouge">onRejected</code>的规范（部分）</p>

<ul>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>onFulilled
</code></pre></div>    </div>

    <p>和</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>onRejected
</code></pre></div>    </div>

    <p>两者都是一个可选的参数：</p>

    <ul>
      <li>如果<code class="language-plaintext highlighter-rouge">onFulilled</code>不是一个函数，它必须被忽视</li>
      <li>如果<code class="language-plaintext highlighter-rouge">onRejected</code>不是一个函数，它必须被忽视</li>
    </ul>
  </li>
  <li>
    <p>如果</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>onFulilled
</code></pre></div>    </div>

    <p>是一个函数：</p>

    <ul>
      <li>它必须在fulfilled时被调用，promise方法中的<code class="language-plaintext highlighter-rouge">value</code>作为第一个参数</li>
      <li>它必须在fulfilled之前<strong>不</strong>被调用</li>
      <li>它不能被多次调用</li>
    </ul>
  </li>
  <li>
    <p>如果</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>onRejected
</code></pre></div>    </div>

    <p>是一个函数：</p>

    <ul>
      <li>它必须在rejected时被调用，promise方法中的<code class="language-plaintext highlighter-rouge">reason</code>作为第一个参数</li>
      <li>它必须在rejected之前<strong>不</strong>被调用</li>
      <li>它不能被多次调用</li>
    </ul>
  </li>
  <li>
    <p>在执行上下文堆栈仅包含平台代码之前，不能调用<code class="language-plaintext highlighter-rouge">onFulfilled</code>或<code class="language-plaintext highlighter-rouge">onRejected</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">onFulfilled</code>和<code class="language-plaintext highlighter-rouge">onRejected</code>必须是一个函数</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">then</code>可以在同一个promise中多次被调用</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">then</code> 必须返回一个<code class="language-plaintext highlighter-rouge">promise</code></li>
</ul>

<p>根据then函数的规则，我们来设计这个then方法</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    const stateArr = ['pending', 'fulfilled', 'rejected']; // 三种状态
    class MyPromise {
        constructor(callback) {
            this.state = stateArr[0]; // 当前状态
            this.value = null; // 完成时的返回值
            this.reason = null; // 失败原因
            
            callback(this.resolve, this.reject); // 调用此function
        }
        
        // callback中执行的resolve方法
        resolve = (value) =&gt; {
            // 判断状态是否需要是pending
            if (this.state === stateArr[0]) {
               this.state = stateArr[1]; // 更新状态为 fulfilled
               this.value = value; // 写入最终的返回值
            }
        }
        
        // callback中执行的reject方法
        reject = (reason) =&gt; {
            // 判断状态是否需要是pending
            if (this.state === stateArr[0]) {
               this.state = stateArr[2]; // 更新状态为 rejected
               this.reason = reason; // 写入拒绝的原因
            }
        }
        
        // then方法
        then = (onFulilled, onRejected) =&gt; {
            // 判断onFulilled 和 onRejected是否是一个函数，如果不是函数则忽略它
            onFulilled = typeof onFulilled === 'function' ? onFulilled : (value) =&gt; value;
            onRejected = typeof onRejected === 'function' ? onRejected : (reason) =&gt; reason;
            
            // 如果状态是fulfilled
            if (this.state === stateArr[1]) {
                // then返回的必须是一个promise
                return new MyPromise((resolve, reject) =&gt; {
                    try {
                        const result = onFulilled(this.value); // 执行传入的onFulilled方法
                        
                        // 如果onFulilled返回的是一个Promise,则调用then方法
                        if (result instanceof MyPromise) {
                            result.then(resolve, reject);
                        } else {
                            resolve(result);
                        }
                    } catch(err) {
                        reject(err);
                    }
                })
            }
            
            // 如果状态是rejected
            if (this.state === stateArr[2]) {
                // then返回的必须是一个promise
                return new MyPromise((resolve, reject) =&gt; {
                    try {
                        const result = onRejected(this.reason); // 执行传入的onRejected方法
                        
                        // 如果onRejected返回的是一个Promise,则调用then方法
                        if (result instanceof MyPromise) {
                            result.then(resolve, reject);
                        } else {
                            resolve(result);
                        }
                    } catch(err) {
                        reject(err);
                    }
                })
            }
        }
    }

复制代码
</code></pre></div></div>

<p>测试一下：</p>

<p>成功返回：</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/11/22/16e927ecf47fee96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<p>失败返回：</p>

<p><img src="https://user-gold-cdn.xitu.io/2019/11/22/16e928372303774e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<h2 id="4继续完善">4.继续完善</h2>

<p>至此，我们的<code class="language-plaintext highlighter-rouge">MyPromise</code>的已经基本可以运行了，但是现在有一个很严重的缺陷，如果遇到异步的请求时候，<code class="language-plaintext highlighter-rouge">resolve</code>不能按上下文执行，这会导致then方法执行失败例如</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    var test = new MyPromise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve(123);
        }, 2000)
    })
    .then(msg =&gt; {
        console.log(msg);
        return 456;
    })
复制代码
</code></pre></div></div>

<p>因为在调用<code class="language-plaintext highlighter-rouge">then</code>方法的时候，<code class="language-plaintext highlighter-rouge">promise</code>的状态还没有改变，而我们的<code class="language-plaintext highlighter-rouge">then</code>方法还没有处理pending状态的逻辑。 这导致执行异步方法的时候，then方法不会返回任何东西
 比如，在上面的例子中，javscript已经把<code class="language-plaintext highlighter-rouge">then</code>方法执行了，但<code class="language-plaintext highlighter-rouge">setTimeout</code>中的方法还在<code class="language-plaintext highlighter-rouge">eventloop</code>中等待执行。 这样需要做的是：</p>

<ul>
  <li>将<code class="language-plaintext highlighter-rouge">then</code>中的方法保存起来，等待<code class="language-plaintext highlighter-rouge">resolve</code>或<code class="language-plaintext highlighter-rouge">reject</code>执行后再调用刚刚保存的<code class="language-plaintext highlighter-rouge">then</code>中的方法</li>
  <li>由于在这期间可能会有多个<code class="language-plaintext highlighter-rouge">then</code>方法会被执行，所以需要用一个数据来保存这些方法
 根据这两点，再来修改一些代码</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 在constructor中新增两个数组分别用于装then中的resolve和reject方法
    constructor(callback) {
        this.resolveArr = [];
        this.rejectArr = [];
    }
    
    // 修改resolve方法
    resolve = (value) =&gt; {
        // 判断状态是否需要是pending
            if (this.state === stateArr[0]) {
               this.state = stateArr[1]; // 更新状态为 fulfilled
               this.value = value; // 写入最终的返回值
               
               this.resolveArr.forEach(fun =&gt; fun(value)) // 循环执行then已插入的resolve方法
            }
    }
    
    // 修改reject方法
    reject = (reason) =&gt; {
        // 判断状态是否需要是pending
            if (this.state === stateArr[0]) {
               this.state = stateArr[1]; // 更新状态为 fulfilled
               this.reason = reason; // 写入最终的返回值
               
               this.rejectArr.forEach(fun =&gt; fun(reason)) // 循环执行then已插入的reject方法
            }
    }
    
    // then方法中需要添加捕捉pending状态的逻辑
    then = (onFulilled, onRejected) =&gt; {
        // 如果状态为pending
        if (this.state === stateArr[0]) {
            return new Promise((resolve, reject) =&gt; {
                // 插入成功时调用的函数
                this.resolveArr.push((value) =&gt; {
                    try {
                        const result = onFulilled(value);
                        if (result instanceof MyPromise) {
                            result.then(resolve, reject);
                        } else {
                            resolve(result);
                        }
                    } catch(err) {
                        reject(err);
                    }
                })
                
                // 插入失败时调用的函数
                this.rejectArr.push((value) =&gt; {
                    try {
                        const result = onRejected(value);
                        if (result instanceof MyPromise) {
                            result.then(resolve, reject);
                        } else {
                            resolve(result);
                        }
                    } catch(err) {
                        reject(err)
                    }
                })
            })
        }
    }
复制代码
</code></pre></div></div>

<p>写好了，测试一下~</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    new MyPromise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve(123);
        }, 2000)
    })
    .then(msg =&gt; {
        console.log(msg);
        return new MyPromise((resolve, reject) =&gt; {
			setTimeout(()=&gt; {
				resolve(456)
			}, 2000);
		})
    })
    .then(msg =&gt; {
        console.log(msg);
    })
复制代码
</code></pre></div></div>

<p><img src="https://user-gold-cdn.xitu.io/2019/11/22/16e9305dfe1d1c32?imageslim" alt="img" /></p>

<h2 id="5promise的其他方法">5.Promise的其他方法</h2>

<p>根据Promise规范实现的<code class="language-plaintext highlighter-rouge">Promise</code>大致已经完成啦，最后我们把Promise中实现的方法也补一下</p>

<ul>
  <li>catch方法</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 在MyPromise原型中实现
    class MyPromise {
        // 调用then中的reject
        catch = (reject) =&gt; {
            this.then(null, reject);
        }
    }
复制代码
</code></pre></div></div>

<ul>
  <li>resolve</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    MyPromise.resolve = (value) =&gt; {
        return new MyPromise((resolve, reject) =&gt; { resolve(value) });
    }
复制代码
</code></pre></div></div>

<ul>
  <li>reject</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    MyPromise.resolve = (reason) =&gt; {
        return new MyPromise((resolve, reject) =&gt; { reject(reason) });
    }
复制代码
</code></pre></div></div>

<ul>
  <li>还有<code class="language-plaintext highlighter-rouge">all</code>，<code class="language-plaintext highlighter-rouge">race</code>，<code class="language-plaintext highlighter-rouge">finally(原型方法)</code>，其实都是根据<strong>Promise中的原型</strong>方法和<strong>Promise规则</strong>实现的，这里就不一一列举啦。需要了解的小伙伴可以<a href="https://github.com/then/promise">自行去看</a></li>
</ul>

<h2 id="最终代码源码地址">最终代码(<a href="https://github.com/IchliebedichZhu/articles/tree/master/promise">源码地址</a>)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const stateArr = ['pending', 'fulfilled', 'rejected']; // 三种状态
class MyPromise {
    constructor(callback) {
        this.state = stateArr[0]; // 当前状态
        this.value = null; // 完成时的返回值
        this.reason = null; // 失败原因
        this.resolveArr = [];
        this.rejectArr = [];
        
        callback(this.resolve, this.reject); // 调用此function
    }
    
    // callback中执行的resolve方法
    resolve = (value) =&gt; {
        // 判断状态是否需要是pending
            if (this.state === stateArr[0]) {
                this.state = stateArr[1]; // 更新状态为 fulfilled
                this.value = value; // 写入最终的返回值
               
                this.resolveArr.forEach(fun =&gt; fun(value)) // 循环执行then已插入的resolve方法
            }
    }
    
    // callback中执行的reject方法
    reject = (reason) =&gt; {
        // 判断状态是否需要是pending
            if (this.state === stateArr[0]) {
               this.state = stateArr[1]; // 更新状态为 fulfilled
               this.reason = reason; // 写入最终的返回值
               
               this.rejectArr.forEach(fun =&gt; fun(reason)) // 循环执行then已插入的reject方法
            }
    }
    
    // then方法
    then = (onFulilled, onRejected) =&gt; {
        // 判断onFulilled 和 onRejected是否是一个函数，如果不是函数则忽略它
        onFulilled = typeof onFulilled === 'function' ? onFulilled : (value) =&gt; value;
        onRejected = typeof onRejected === 'function' ? onRejected : (reason) =&gt; reason;

        // 如果状态为pending
        if (this.state === stateArr[0]) {
            return new MyPromise((resolve, reject) =&gt; {
                // 插入成功时调用的函数
                this.resolveArr.push((value) =&gt; {
                    try {
                        const result = onFulilled(value);
                        if (result instanceof MyPromise) {
                            result.then(resolve, reject);
                        } else {
                            resolve(result);
                        }
                    } catch(err) {
                        reject(err);
                    }
                })
                
                // 插入失败时调用的函数
                this.rejectArr.push((value) =&gt; {
                    try {
                        const result = onRejected(value);
                        if (result instanceof MyPromise) {
                            result.then(resolve, reject);
                        } else {
                            resolve(result);
                        }
                    } catch(err) {
                        reject(err)
                    }
                })
            })
            
        }
        
        // 如果状态是fulfilled
        if (this.state === stateArr[1]) {
            // then返回的必须是一个promise
            return new MyPromise((resolve, reject) =&gt; {
                try {
                    const result = onFulilled(this.value); // 执行传入的onFulilled方法
                    
                    // 如果onFulilled返回的是一个Promise,则调用then方法
                    if (result instanceof MyPromise) {
                        result.then(resolve, reject);
                    } else {
                        resolve(result);
                    }
                } catch(err) {
                    reject(err);
                }
            })
        }
        
        // 如果状态是rejected
        if (this.state === stateArr[2]) {
            // then返回的必须是一个promise
            return new MyPromise((resolve, reject) =&gt; {
                try {
                    const result = onRejected(this.reason); // 执行传入的onRejected方法
                    
                    // 如果onRejected返回的是一个Promise,则调用then方法
                    if (result instanceof MyPromise) {
                        result.then(resolve, reject);
                    } else {
                        resolve(result);
                    }
                } catch(err) {
                    reject(err);
                }
            })
        }
    }

    // 调用then中的reject
    catch = (reject) =&gt; {
        this.then(null, reject);
    }
}

MyPromise.resolve = (value) =&gt; {
    return new MyPromise((resolve, reject) =&gt; { resolve(value) });
}

MyPromise.resolve = (reason) =&gt; {
    return new MyPromise((resolve, reject) =&gt; { reject(reason) });
}

复制代码
</code></pre></div></div>

<h2 id="小结">小结</h2>

<p>这次我们了解了promise是如何实现的：</p>

<ul>
  <li>必须是构造函数</li>
  <li>三种状态（pending，resolve，reject）</li>
  <li>then方法（promise中必须要有的方法）</li>
</ul>

<p>从构造函数开始，到三种状态的实现，最后实现then方法一步步根据<code class="language-plaintext highlighter-rouge">Promise规则</code>来实现Promise。了解完以后就可以在面试官面前手写一个Promise啦！😄</p>

<p>作者：IchmagR
链接：https://juejin.im/post/6844904002946072589
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
:ET