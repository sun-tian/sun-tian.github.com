I"'#<h1 id="js中的hasownproperty和isprototypeof"><a href="https://juejin.im/post/6844903569087266823">js中的hasOwnProperty()和isPrototypeOf()</a></h1>

<h1 id="js中的hasownproperty和isprototypeof-1">js中的hasOwnProperty()和isPrototypeOf()</h1>

<blockquote>
  <p>这两个属性都是<code class="language-plaintext highlighter-rouge">Object.prototype</code>所提供:<code class="language-plaintext highlighter-rouge">Object.prototype.hasOwnProperty()</code>和<code class="language-plaintext highlighter-rouge">Object.prototype.isPropertyOf()</code>
  先讲解<code class="language-plaintext highlighter-rouge">hasOwnProperty()</code>方法和使用。在讲解<code class="language-plaintext highlighter-rouge">isPropertyOf()</code>方法和使用</p>
</blockquote>

<p><strong>看懂这些至少要懂原型链</strong></p>

<h2 id="一objectprototypehasownproperty">一、Object.prototype.hasOwnProperty()</h2>

<h3 id="概述">概述</h3>

<p>hasOwnProperty()方法用来判断某个对象是否含有指定的自身属性</p>

<h3 id="语法">语法</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>obj.hasOwnProperty("属性名");//实例obj是否包含有圆括号中的属性,是则返回true,否则是false复制代码
</code></pre></div></div>

<h3 id="描述">描述</h3>

<p>所有继承了<code class="language-plaintext highlighter-rouge">Object.prototype</code>的对象都会从原型链上继承到<code class="language-plaintext highlighter-rouge">hasOwnProperty</code>方法，这个方法检测一个对象是否包含一个特定的属性，
和<code class="language-plaintext highlighter-rouge">in</code>不同，这个方法会忽略那些从原型链上继承的属性。</p>

<h3 id="实例">实例</h3>

<h4 id="1使用hasownproperty方法判断某对象是否含有特定的自身属性">1.使用hasOwnProperty()方法判断某对象是否含有特定的自身属性</h4>

<p>下面的例子检测了对象 o 是否含有自身属性 prop：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var o =new Object();
o.prop="exists";

function change(){
  o.newprop=o.prop;
  delete o.prop;
}

o.hasOwnProperty("prop")//true
change()//删除o的prop属性
o.hasOwnProperty("prop")//false
//删除后在使用hasOwnProperty()来判断是否存在，返回已不存在了复制代码
</code></pre></div></div>

<h4 id="2自身属性和继承属性的区别">2.自身属性和继承属性的区别</h4>

<p>下面的列子演示了<code class="language-plaintext highlighter-rouge">hasOwnProperty()</code>方法对待自身属性和继承属性的区别。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var o =new Object();
o.prop="exists";
o.hasOwnProperty("prop");//true 自身的属性
o.hasOwnProperty("toString");//false 继承自Object原型上的方法
o.hasOwnProperty("hasOwnProperty");//false 继承自Object原型上的方法复制代码
</code></pre></div></div>

<h4 id="3修改原型链后hasownproperty的指向例子">3.修改原型链后hasOwnProperty()的指向例子</h4>

<p>下面的列子演示了<code class="language-plaintext highlighter-rouge">hasOwnProperty()</code>方法对待修改原型链后继承属性的区别</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var o={name:'jim'};
function Person(){
  this.age=19;
}
Person.prototype=o;//修改Person的原型指向
p.hasOwnProperty("name");//false 无法判断继承的name属性
p.hasOwnProperty("age");//true;复制代码
</code></pre></div></div>

<h4 id="4使用hasownproperty遍历一个对象自身的属性">4.使用hasOwnProperty()遍历一个对象自身的属性</h4>

<p>下面的列子演示了如何在遍历一个对象忽略掉继承属性，而得到自身属性。</p>

<p><strong>注意· <code class="language-plaintext highlighter-rouge">forin</code> 会遍历出对象继承中的可枚举属性</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var o={
  gender:'男'
}
function Person(){
  this.name="张三";
  this.age=19;
}
Person.prototype=o;
var p =new Person();
for(var k in p){
  if(p.hasOwnProperty(k)){
    console.log("自身属性："+k);// name ,age
  }else{
    console.log("继承别处的属性："+k);// gender
  }
}复制代码
</code></pre></div></div>

<h4 id="5hasownproperty方法有可能会被覆盖">5.hasOwnProperty方法有可能会被覆盖</h4>

<p>如果一个对象上拥有自己的<code class="language-plaintext highlighter-rouge">hasOwnProperty()</code>方法，则原型链上的<code class="language-plaintext highlighter-rouge">hasOwnProperty()</code>的方法会被覆盖掉</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var o={
  gender:'男',
  hasOwnProperty:function(){
    return false;
  }
}

o.hasOwnProperty("gender");//不关写什么都会返回false
//解决方式，利用call方法
({}).hasOwnProperty.call(o,'gender');//true
Object.prototype.hasOwnProperty.call(o,'gender');//true复制代码
</code></pre></div></div>

<h2 id="二objectprototypeisprototypeof">二、Object.prototype.isPrototypeOf()</h2>

<h3 id="概述-1">概述</h3>

<p><code class="language-plaintext highlighter-rouge">isPrototypeOf()</code>方法测试一个对象是否存在另一个对象的原型链上</p>

<h3 id="语法-1">语法</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//object1是不是Object2的原型,也就是说Object2是Object1的原型，,是则返回true,否则false
object1.isPrototypeOf(Object2);复制代码
</code></pre></div></div>

<h3 id="描述-1">描述</h3>

<p><code class="language-plaintext highlighter-rouge">isPrototypeOf()</code>方法允许你检查一个对像是否存在另一个对象的原型链上</p>

<h3 id="实例-1">实例</h3>

<h4 id="1利用isprototypeof检查一个对象是否存在另一个对象的原型上">1.利用isPrototypeOf()检查一个对象是否存在另一个对象的原型上</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var o={};
function Person(){};
var p1 =new Person();//继承自原来的原型，但是现在已经无法访问
Person.prototype=o;
var p2 =new Person();//继承自o
console.log(o.isPrototypeOf(p1));//false o是不是p1的原型
console.log(o.isPrototypeof(p2));//true  o是不是p2的原型复制代码
</code></pre></div></div>

<h4 id="2利用ispropertyof检查一个对象是否存在一另一个对象的原型链上">2.利用isPropertyOf()检查一个对象是否存在一另一个对象的原型链上</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var o={};
function Person(){};
var p1 =new Person();//继承自原来的原型，但是现在已经无法访问
Person.prototype=o;
var p2 =new Person();//继承自o
console.log(o.isPrototypeOf(p1));//false o是不是p1的原型
console.log(o.isPrototypeof(p2));//true  o是不是p2的原型

console.log(Object.prototype.isPrototypeOf(p1));//true
console.log(Object.prototype.isPrototypeOf(p2));//true复制代码
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">p1</code>的原型链结构是<code class="language-plaintext highlighter-rouge">p1</code>=&gt;原来的<code class="language-plaintext highlighter-rouge">Person.prototype</code>=&gt;<code class="language-plaintext highlighter-rouge">Object.prototype</code>=&gt;<code class="language-plaintext highlighter-rouge">null</code>
  <code class="language-plaintext highlighter-rouge">p2</code>的原型链结构是<code class="language-plaintext highlighter-rouge">p2</code>=&gt; <code class="language-plaintext highlighter-rouge">o</code> =&gt;<code class="language-plaintext highlighter-rouge">Object.prototype</code>=&gt;<code class="language-plaintext highlighter-rouge">null</code>
  <code class="language-plaintext highlighter-rouge">p1</code>和<code class="language-plaintext highlighter-rouge">p2</code>都拥有<code class="language-plaintext highlighter-rouge">Object.prototype</code>所以他们都在<code class="language-plaintext highlighter-rouge">Object.Prototype</code>的原型链上</p>
</blockquote>

<h2 id="三总结">三、总结</h2>

<ol>
  <li>hasOwnProperty：是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。</li>
  <li>isPrototypeOf是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回true，否则返回false。</li>
</ol>

<p><a href="https://juejin.im/post/6844903855474343950">Link</a></p>

:ET