---
layout:     post           # 使用的布局（不需要改）
title:      前端面经总结
subtitle:   前端面经总结 #副标题
date:       2020-12-14             # 时间
author:     甜果果                    # 作者
header-img: https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@1.0/assets/img/home-bg-art.jpg    #背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 前端
    - 面试

---

## VUE

### 说说你对SPA单页面的理解，它的优缺点分别是什么?

SPA ( single- page application)仅在Web页面初始化时加载相应的HTML、JavaScript 和CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转;取而代之的是利用路由机制实现HTML内容的变换，UI 与用户的交互，避免页面的重新加载。

-   用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染;基于上面一点，SPA相对对服务器压力小;
-   前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理;
-   初次加载耗时多:为实现单页Web应用功能及显示效果,
    需要在加载页面的时候将JavaScript、cSS统一加载， 部分页面按需加载;
-   前进后退路由管理:由于单页应用在一-个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理;
-   SEO难度较大:由于所有的内容都在一个页面中动态替换显示，所以在SEO.上其有着天然的弱势。

### **聊聊对vue的理解**

>   vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的

### VUE的指令有哪些？

```css
v-if 用于条件渲染
v-show 用于条件渲染，两者的区别请参考下一个问题
v-for 用于列表渲染
v-on  监听事件
v-bind 动态绑定
v-html 渲染html元素
v-model 数据双向绑定
```

### 怎么理解Vue的单向数据流？

所有的prop都使得其父子prop之间形成了一个单向下行绑定:父级prop的更新会向下流动到子组件中，但是反过来则不行。
这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
额外的，每次父级组件发生更新时，子组件中所有的prop都将会刷新为最新的值。
这意味着你不应该在-个子组件内部改变prop。如果你这样做了，Vue会在浏览器的控制台中发出警告。
子组件想修改时，只能通过$emit派发-个自定义事件，父组件接收到后，由父组件修改。
●这个prop用来传递-个初始值;这个子组件接下来希望将其作
为一个本地的prop数据来使用。在这种情况下，最好定义一个本地的data属性并将这个prop用作其初始值:
props: [ ' initialCounter'],
data: function () {
return {
counter: this . initialCounter
}

●这个prop以一种原始的值传入且需要进行转换。在这种情况
下，最好使用这个prop的值来定义一个计算属性
props: [ 'size'],
computed: {
normalizedSize: .
function () {
return this. size. trim( ) . toLowerCase( )
}
}

### **Vue的双向数据绑定，V-model的原理是什么？**

**Vue的双向数据绑定**是由数据劫持结合发布者订阅者实现的。 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。 在数据变动时作你想做的事

**原理** 通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新 在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据

### **v-if和v-show区别**

v-if是真正的条件渲染,因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建;也是惰性的:如果在初始渲染时条件为假，则什么也不做一直 到条件第一次变为真时，才会开始渲染条件块。

v-show就简单得多不管初始条件是什么，元素总是会被渲染,
并且只是简单地基于CSS的"display"属性进行切换。

所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景;v-show则适用于需要非常频繁切换条件的场景。

### **v-for和v-if为什么不能放于同一级**

v-for优先级高于v-if，放于同级可能会重复渲染两次v-if，建议把v-for放于v-if所在的外层元素

### **nextTick**

原理:eventloop事件循环

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

### **v-for中key的原理**

```js
key 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。不指定key时，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试
就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。
```

### vue生命周期

Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom->渲染、更新->渲染、卸载等一系列过程，我们称这是Vue的生命周期。

| No.  | name          | feature                                                      |
| ---- | ------------- | ------------------------------------------------------------ |
| 1    | beforeCreate  | 初始化界面前，组件实例被创建之初，组件的属性生效之前         |
| 2    | created       | 初始化界面后，拿到data，props，methods、computed和watch组件实例已经完全创建，属性也绑定，但真实dom还没有还不可用 |
| 3    | beforeMount   | 渲染dom前，在挂载开始之前被调用:相关的render函数首次被调用   |
| 4    | mounted       | 渲染dom后，拿到$ el，el被新创建的vm.$ el替换，并挂载到实例.上去之后调用该 |
| 5    | beforeUpdate  | 更新前组件数据更新之前调用，发生在虚拟DOM打补丁之前          |
| 6    | update        | 更新后，拿到更新后的dom组件数据更新之后                      |
| 7    | activited     | 被 keep-alive 缓存的组件激活时调用keep-alive专属，组件被激活时调用 |
| 8    | deadctivated  | 被 keep-alive 缓存的组件停用时调用keep-alive专属，组件被销毁时调用 |
| 9    | beforeDestory | 卸载组件前组件 销毁前调用                                    |
| 10   | destoryed     | 卸载组件后，组件销毁后调用                                   |
| 11   | errorCaptured | 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例<br/> 以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 |

### Vue的父组件和子组件生命周期钩子函数执行顺序?
Vue的父组件和子组件生命周期钩子函数执行顺序可以归类为以下4部分:
●加载渲染过程
父beforeCreate ->父created ->父beforeMount->子
beforeCreate ->子created ->子beforeMount ->子mounted ->父mounted
●子组件更新过程
父beforeUpdate ->子beforeUpdate ->子updated ->父updated

●父组件更新过程
父 beforeUpdate -> 父 updated

●销毁过程

父 beforeDestroy-> 子 beforeDestroy-> 子 destroyed -> 父
destroyed

### **computed和watch区别和运用的场景？**

**computed:**是计算属性，依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一 次获取computed的值时才会重新计算computed的值;
**watch:**更多的是「观察」的作用，类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作;

-   当我们需要进行数值计算，并且依赖于其它数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算;
-   当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作(访问一个API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

### vue的底层

博客里。

### vue里，数据改变怎么触发页面渲染，如果没有节点使用这个数据，会是什么样的过程

### vue的双向绑定原理

```js
vue的双向绑定是通过数据劫持和发布者-订阅者模式实现的，数据劫持又是通过Object.defineProperty()实现的

Object.defineProperty(data,'a',{
    enumerable:true,//是否可枚举
    writable:true,//是否可写
    configurable:true,//是否可配置
    get(){
        return this.a//读取data对象的a属性时，触发get方法
    },
    set(val){
        this.a=val;//修改data对象的a属性时，触发set方法
    }
})
mvvm的数据变化更新视图，是通过Object.defineProperty()实现的；视图更新变化数据，是通过事件监听实现的。

发布者-订阅者的实现过程:
1. 实现一个监听器Observer，劫持并监听所有属性，如果有变化，就通知订阅者
2. 实现一个订阅者Watcher，收到属性的变化通知并执行响应的函数，从而更新视图
3. 实现一个解析器Compiler，可以扫描并解析每个节点的相关指令，初始化模板数据和对应的订阅器
```

### **vuex的流程**

```text
页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。
mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中
通过mapGetter来动态获取state中的值
```

### **vnode的diff算法原理**

虚拟dom是对真实dom的一种映射，新旧Vnode比较同层级的节点，然后根据两者的差异只更新有差异的部分，生成新的视图，而不是对树进行逐层搜素遍历，因此时间复杂度是O(n)。虚拟dom可以减少页面的回流和重绘，提升性能

### **vuex有哪几种状态和属性**

>   state中保存着共有数据，数据是响应式的
>   getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用
>   mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的
>   actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。
>   modules：模块化vuex

### **vue路由的两种模式**

>   hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。
>   history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法
>   这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。

### **vue中 key 值的作用**

>   当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。
>
>   key的作用主要是为了高效的更新虚拟DOM。

### **DOM diff原理**

>   如果元素类型发生变化，直接替换
>   如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引

### **`$route`和`$router`的区别**

>   $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
>   $router是“路由实例”对象包括了路由的跳转方法，钩子函数等。

### vue-router守卫

>   导航守卫 router.beforeEach 全局前置守卫
>   to: Route: 即将要进入的目标（路由对象）
>   from: Route: 当前导航正要离开的路由
>   next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。
>   next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
>   next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。

```text
// main.js 入口文件
    import router from './router'; // 引入路由
    router.beforeEach((to, from, next) => { 
      next();
    });
    router.beforeResolve((to, from, next) => {
      next();
    });
    router.afterEach((to, from) => {
      console.log('afterEach 全局后置钩子');
    });
```

路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫

```text
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫

```text
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开
    // 可以访问组件实例 `this`
    // 比如还未保存草稿，或者在用户离开前，
    将setInterval销毁，防止离开之后，定时器还在调用。
  }
}
```

### **vue修饰符**

>   stop：阻止事件的冒泡
>   prevent：阻止事件的默认行为
>   once：只触发一次
>   self：只触发自己的事件行为时，才会执行

### **vue项目中的性能优化**

>   1.不要在模板里面写过多表达式
>
>   2.循环调用子组件时添加key
>
>   3.频繁切换的使用v-show，不频繁切换的使用v-if
>
>   4.尽量少用float，可以用flex
>
>   5.按需加载，可以用require或者import()按需加载需要的组件
>
>   6.路由懒加载

### vue.extend和vue.component

>   extend 是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里 还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。
>   Vue.component 你可以创建 ，也可以取组件。
>
>   常见的兼容问题
>   png24位的图片在iE6浏览器上出现背景 解决方案是做成PNG8.也可以引用一段脚本处理.
>
>   浏览器默认的margin和padding不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。
>
>   IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。
>
>   浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}

### 状态管理 

### 3、Class与Style如何动态绑定?
Class可以通过对象语法和数组语法进行动态绑定:
●对象语法:

```js
<div v-bind:class="{ active: isActive, ' text-danger' : hasError }"></di
data: {
isActive: true,
hasError: false
}
```

●数组语法:
```js
<div v-bind:class="[ isActive ? activeClass : '' ，errorClass]"></div>
data: {
activeClass :
active ' ,
errorClass :
' text-danger
}
```

Style也可以通过对象语法和数组语法进行动态绑定:
●对象语法:

```js
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }">
data: {
activeColor:' red' ,
fontSize: 30
}
```

数组语法:
```js
<div v-bind: style="[ styleColor, styleSize]"></div>
data: (
styleColor: [
color:' red '
],
styleSize: [
fontSize: ' 23px
]
]
```

### 使用前端框架（angular/vue/react）带来哪些好处，相对于使用jQuery

### **VUE和REACT有什么区别？**

>   react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；
>
>   vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。

```text
=>  相同点：
	1.数据驱动页面，提供响应式的试图组件
	2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范
	3.数据流动单向，都支持服务器的渲染SSR
	4.都有支持native的方法，react有React native， vue有wexx
=>  不同点：
	1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
	2.数据渲染：大规模的数据渲染，react更快
	3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
	4.开发风格：react推荐做法jsx + inline style把html和css都写在js了
		    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
```
