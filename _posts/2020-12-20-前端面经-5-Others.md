---
layout:     post           # 使用的布局（不需要改）
title:      前端面经总结-5-Others
subtitle:   前端面经总结-5-Others #副标题
date:       2020-12-14             # 时间
author:     甜果果                    # 作者
header-img: https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@1.0/assets/img/home-bg-art.jpg    #背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 前端
    - 面试

---

## react

**redux中的reducer（纯函数）**

```text
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state ->  action ->  state
```

**3.react的refs**

```text
refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，
它将接受地城dom元素或组件的已挂在实例，作为第一个参数
```

**4.react中的keys**

```text
帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它
```

**5.React的生命周期**

```text
三个状态：Mounting(已插入真实的DOM）
	  Updating(正在被重新渲染)
	  Unmounting(已移除真实的DOM)
componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，
componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用
```

**6.React子组件向父组件传值**

```text
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。
```

**7.为什么虚拟DOM会提高性能 [www.zhihu.com/question/29…](https://www.zhihu.com/question/29504639?sort=created)**

```text
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能
具体实现步骤：
	·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中
        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异
	·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
```

**8.diff算法**

```text
1.把树形结构按照层级分解，只比较同级元素
2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记
3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面
Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用
react只会匹配相同的class的component（这里的class指的是组件的名字）
合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制
4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能	
```

**9.简述下flux的思想**

```text
flux的最大特点，就是数据的‘单向流动’
1.用户访问View
2.View发出用户的Action
3.Dispatcher收到Action,要求state进行相应的更新
4.store更新后，发出一个‘change’事件后，更新页面
```

**10.reac性能优化是哪个周期函**

```text
shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，
如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能
```

**11.react怎么划分业务组件和技术组件**

```text
根据组件的职责通常把组件分为UI组件和容器组件
UI组件负责UI的呈现，容器组件负责管理数据和逻辑
两者通过React-redux提供connect方法联系起来
```

**12.setState**

```text
setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列
而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值	
那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误

同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state

同步更新state:
	setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。
	第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行
	也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步

例子：componentDidMount() {

	fetch('https://test.com')
    
	.then((res) => res.json())
    
	.then(
    (data) => {
this.setState({ data:data });
			StatusBar.setNetworkActivityIndicatorVisible(false);
        }
```



### React的生命周期

>   beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。
>   created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有
>   beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点
>   mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点
>   beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器
>   updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环
>   beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件
>   destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁

### Jquery与 jQuery UI 有啥区 别？

*jQuery 是一个 js 库，主要提供的功能是选择器， 属性修改和事件绑定等等。

*jQuery UI则是在 jQuery的基础上， 利用 jQuery的扩展性， 设计的插件。

提供了一些常用的界面元素，诸如对话框、拖动 行为、改变大小行为等等

### jquery 中如何将数组转化为 json字符串， 然 后 再转化回来？

jQuery中没有提供这个功能， 所以你需要先编写两 个 jQuery 的扩展：

```js
$.fn.stringifyArray = function(array) { return JSON.stringify(array) }
$.fn.parseArray = function(array) { return JSON.parse(array) }
```

然后调用： 

$("").stringifyArray(array)

### 有用过jQuery是哈 那你觉得jQuery和React开发各自的优缺点是什么？ 

### 你觉得在开发[项目]()的时候React性能好还是jQuery性能好？ 

### React好在什么地方？

### 什么情况下不应该选择React而需要选择jQuery？ 

### 用jQuery选择的元素和js选择器选择的元素一样吗？

### 怎么让jQuery元素对象和js的dom对象转化 

### 你们开发的时候 选择的是哪个版本的React 

### Ant design用过哪些组件？ 

### 自己封装过组件吗？ 

### 用过model组件吧，现在我要自己封装一个，说一下思路 

### react组件通信 

### 受控组件跟非受控组件 

## 工具 

### npm 模块安装机制

-   发出`npm install`命令

-   查询node_modules目录之中是否已经存在指定模块

-   -   若存在，不再重新安装

    -   若不存在

    -   -   npm 向 registry 查询模块压缩包的网址
        -   下载压缩包，存放在根目录下的`.npm`目录里
        -   解压压缩包到当前项目的`node_modules`目录

### npm 实现原理

输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：

1.  **执行工程自身 preinstall**当前 npm 工程如果定义了 preinstall 钩子此时会被执行。
2.  **确定首层依赖模块**首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。
    工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。
3.  **获取模块**
    获取模块是一个递归的过程，分为以下几步：

-   获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。
-   获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。
-   查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。

### package.json文件

管理你所安装的npm包的依赖，在开发过程中能清楚的查询安装的包的版本以及项目中使用的包依赖，便于开发组成员共享。以及项目的配置信息（比如名称、版本号、项目描述、许可证等元数据）。运行npm install命令可以自动下载package.json文件中运行和开发环境中所需的依赖

name  version  description  keywords  homepage  hugs  license  author  files  main  repository  scripts  config  dependencies  devDependencies  engines  private

### package.json里面dev是干嘛的？

devDependencies字段是一个对象，它指定了项目开发时依赖的模块名和版本范围映射。如果有人要用你的模块，但他们可能不需要你开发所使用的外部测试或者文档框架。

### 详细讲讲cdn 

**CDN（内容分发网络）**

**CDN是**内容分发网络（Content Delivery Network或Content Ddistribute Network），**主要的功能是**解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。

**它的原理是**广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术
将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）

**资源上传cdn之后，当用户访问cdn的资源地址之后会经历下面的步骤：**

- 首先经过本地的dns解析，请求cname指向的那台cdn专用的dns服务器。
- dns服务器返回全局负载均衡的服务器ip给用户
- 用户请求全局负载均衡服务器，服务器根据ip返回所在区域的负载均衡服务器ip给用户
- 用户请求区域负载均衡服务器，负载均衡服务器根据用户ip选择距离近的，并且存在用户所需内容的，负载比较合适的一台缓存服务器ip给用户。当没有对应内容的时候，会去上一级缓存服务器去找，直到找到资源所在的源站服务器，并且缓存在缓存服务器中。用户下一次在请求该资源，就可以就近拿缓存了。

### git 常用命令哪些？ 

git init、git config、git add、git commit、git push、git featch、git branch、git checkout

### 如何设计突发大规模并发架构？

先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等

编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

标注样式编写人，各模块都及时标注（标注关键样式 调用的地方）；

页面进行标注（例如 页面 模块 开始和结束）；

CSS跟 HTML 分文件夹并行存放，命名都得统一 （例 如 style.css）

JS 分文件夹存放 命民以该 JS 功能为准英文翻译；

图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理

## webpack

### **webpack运行流程**

分为初始化、编译、输出三个阶段.

**初始化**：

1.  从配置文件和shell文件读取、合并参数；
2.  加载plugin
3.  实例化compiler

**编译**

1.  从entry发出，针对每个module串行调用对应loader翻译文件内容
2.  找到module依赖的module，递归进行编译处理

**输出**：

1.  把编译后module组合成chunk
2.  把chunk转换成文件，输出到文件系统

### webpack性能优化

优化可以从两个方面考虑，一个是优化开发体验，一个是优化输出质量。

**优化开发体验**

-   缩小文件搜索范围。涉及到webpack如何处理导入文件，不再赘述，不会的可以自行搜索。由于loader对文件转换操作很耗时，应该尽量减少loader处理的文件，可以使用include命中需要处理的文件，缩小命中范围。
-   使用DllPlugin，提升构建速度
-   使用happyPack开启多线程
-   使用UglifyJs压缩代码(只支持es5)，uglifyes支持es6，两个插件不能同时开启。使用ParalellUgifyPlugin开启多个子进程压缩，既支持UglifyJs又支持uglifyes
-   使用自动刷新：监听到代码改变后，自动编译构建可运行代码并刷新页面
-   开启模块热替换:在不刷新网页的同时实现实时预览

**优化输出质量**减少首屏加载时间

-   区分环境
-   压缩代码
-   CDN加速
-   使用Tree shaking
-   提取公共代码
-   按需加载

提升流畅度，即代码性能:

-   使用PrePack优化代码运行时的效率
-   开启Scope Hoisting，让webpack打包出来的代码更小、运行更快

### **loader的原理**

loader能把源文件翻译成新的结果，一个文件可以链式经过多个loader编译。以处理scss文件为例:

-   sass-loader把scss转成css
-   css-loader找出css中的依赖，压缩资源
-   style-loader把css转换成脚本加载的JavaScript代码

### plugin原理

plugin用于扩展webpack功能。

-   webpack启动后，在读取配置时会先执行new BasicPlugin(options)初始化一个BasicPlugin获得它的实例
-   调用BasicPlugin.apply(compiler）给插件实例传递compiler对象
-   插件实例获取compiler对象后，通过compiler.plugin(事件名，回调函数)监听webpack广播出的事例



## 计算机网络

### **从输入url地址到页面相应都发生了什么？**

1.  DNS解析
2.  TCP连接
3.  发送HTTP请求
4.  服务器处理请求并返回HTTP报文
5.  浏览器解析渲染页面
6.  连接结束

```text
1、浏览器的地址栏输入URL并按下回车。
2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。
4、根据IP建立TCP连接（三次握手）。
5、HTTP发起请求。
6、服务器处理请求，浏览器接收HTTP响应。
7、渲染页面，构建DOM树。
8、关闭TCP连接（四次挥手）
```

```text
1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存
2.浏览器与服务器建立tcp链接（三次握手）
3.浏览器向服务器发送http请求(请求和传输数据）
4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器
5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤
6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来
```

### url从输入到输出的过程

1. 构建请求
    构建请求行，请求行包括请求方法、请求http版本、URI
    Get/Http/1.0
2. 查找强缓存
    检查强缓存，命中则直接使用，否则检查协商缓存
3. DNS解析
    域名与IP地址映射
4. 建立tcp连接
    chrome限制同一域名下最多6个tcp连接
    -   通过三次握手建立连接
        -   三次握手过程:
            1.客户端向服务器发送连接请求，传递一个数据包syn，此时客户端处于SYN_SEND状态
            2.服务器接收syn报文后，会以自己的syn报文作为应答，传递数据包syn+ack,此时服务器处于SYN-REVD状态
            3.客户端接收syn报文后，发送一个数据包ack，此时客户端处于ESTABLISHED状态，双方已建立连接
    -   进行数据传输
    -   通过四次挥手断开连接
        -   四次挥手过程:
            1. 客户端发送一个FIN报文，报文中指定一个序列号，此时客户端处于FIN_WAIT1状态，等待服务器确认
            2. 服务器接收到FIN后，会发送ACK确认报文，表明已经收到客户端报文，此时服务端处于CLOSE_WAIT2状态
            3. 服务器发送FIN，告诉客户端想断开连接，此时服务端处于LAST_CHECK阶段
            4. 客户端收到FIN后，一样发送一个ACK作为应答，此时客户端处于TIME_WAIT阶段。需要过一段时间确认服务端收到自己的ACK报文
                后才会进入CLOSED状态
            5. 发送http请求
            6. 网络响应
            7. 浏览器解析和渲染
                分为构建dom树、样式计算、生成布局树。
            8. 生成布局
                触发回流和重绘

**介绍下半连接队列**

```js
服务器第一次接收到客户端的SYN后，会处于SYN-REVD阶段，此时双方还没有建立完全的连接，
服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称为半连接队列

已经完成三次握手并建立连接，就叫全连接队列
```



### http由哪些字段组成 

Start line、Headers、Body

![image-20201016211209757](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201016224906.png)



### **客户端缓存**

客户端缓存分为cookie、localStorage、sessionStorage、indexedDB，网上有关的文章很多，就不详细说了

### **浏览器缓存**

**强缓存**

不向http发送请求，返回状态码304.

检查强缓存有两个字段: http1.0使用expires，代表过期时间，但是服务器时间和客户端时间可能不一致。为了弥补这个缺点，http1.1使用cache-control的max-age字段，cache-control有多个指令

-   public 允许客户端和代理服务器缓存
-   private 允许客户端缓存
-   no-store 不使用缓存
-   no-cache 使用协商缓存 两个字段都存在，cache-control优先级高于expires

**协商缓存**向http发送请求，返回状态码200

检查协商缓存有两个字段: http1.0使用last-modified，即最后修改时间。

1.  在浏览器向服务器发送请求后，服务器会在响应头上加上这个字段
2.  浏览器接收后，如果再次请求，会在请求头上携带If-Modified-Since
3.  服务器拿到If-Modified-Since字段后，会和服务器中该资源的最后修改时间对比,如果请求头中这个值小于最后修改时间，更新资源；否则返回304，告诉浏览器直接使用缓存

http1.1使用etag，etag是服务器根据当前文件内容，给文件生成的唯一标识，只要内容改变，这个值就会变。etag优先级高于last-modifed

缓存位置，按优先级从高到低分别是:

-   service worker
-   memory cache
-   disk cache
-   push cache

### 优化中会提到缓存的问题，问：静态资源或者接口等如何做缓存优化

### **token、cookie、session三者的理解？？？！！！**

```text
1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式    

2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名
    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）

3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）
    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```



### **js中跨域方法**

>   同源策略（协议+端口号+域名要相同）
>
>   1、jsonp跨域(只能解决get） 原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容
>   步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据
>
>
>   2、document.domain 基础域名相同 子域名不同
>
>   3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name
>
>   4、服务器设置对CORS的支持 原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求
>
>   5、利用h5新特性window.postMessage()

### http缓存（如果有cdn会怎么样 +3

博客里。

### http三次握手四次挥手，tcp的包有序号吗？tcp为什么需要三次握手 

博客里。

### Linux相关

**如何查看系统内核的版本**    cat /proc/version

**如何查看系统当前的 IP 地址**    ifconfig -a

**如何查看磁盘还有多少剩余空间**      df -ah 

**如何在系统中管理服务**    service

**如何查看文件夹大小**    du -h --max-depth=1

**如何查看你系统中开放的端口号**    netstat 

**如何查看某个进程对 CPU 的使用情况**      top或者ps

**修改文件夹目录权限**   chmod 777 mm.txt

**服务器传送命令**  scp -P 5722 -r pathA root@211.82.97.237:pathB

**Linux统计文本行数**    wc - lcw file1 file2

### OSI七层模型和TCP/IP四层模型

OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。

![https://img-blog.csdn.net/20180411120702438?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTIxNTU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201213170755.png)

![image-20201213170932876](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201213170933.png)

### 三次握手和四次挥手

三次握手：

![img](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201213174515.png)

第一次握手：建立连接时，[客户端](http://baike.baidu.com/view/930.htm)发送[syn](http://baike.baidu.com/view/488528.htm)包（syn=j）到[服务器](http://baike.baidu.com/view/899.htm)，并进入[SYN_SENT](http://baike.baidu.com/view/840439.htm)状态，等待服务器确认；SYN：同步序列编号（**Synchronize Sequence Numbers**）。

[第二次握手](http://baike.baidu.com/view/205949.htm)：[服务器](http://baike.baidu.com/view/899.htm)收到[syn](http://baike.baidu.com/view/488528.htm)包，必须确认客户的SYN（[ack](http://baike.baidu.com/view/204040.htm)=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入[SYN_RECV](http://baike.baidu.com/view/1520054.htm)状态；

第三次握手：[客户端](http://baike.baidu.com/view/930.htm)收到[服务](http://baike.baidu.com/view/133203.htm)器的SYN+ACK包，向[服务器](http://baike.baidu.com/view/899.htm)发送确认包ACK([ack](http://baike.baidu.com/view/204040.htm)=k+1），此包发送完毕，客户端和服务器进入[ESTABLISHED](http://baike.baidu.com/view/1137549.htm)（TCP连接成功）状态，完成三次握手。

**四次挥手：**

![img](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201213174601.png)

1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

【问题3】为什么不能用两次握手进行连接？

答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

​    现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### **tcp和udp区别**

1.  tcp只能一对一通信，udp可以一对一、一对多、多对多通信，即支持多播和广播
2.  tcp首部开销消耗32字节，udp仅消耗8个字节
3.  tcp适合对数据安全性要求高的场景，比如文件传输，udp适合对数据实时性要求高的场景，比如视频通话、语音通话
4.  tcp是有状态连接，udp是无状态的连接
5.  tcp-可靠传输 udp-不可靠传输
6.  tcp-面向字节流 udp-面向报文

### **tcp怎么保证可靠性**

```js
1. 超时重传机制
2. 对失序数据进行重排序
3. 应答机制
4. 滑动窗口
5. 拥塞控制
```

### tcp拥塞控制

博客里。

### dns查询过程数据怎么流动的  

博客里。  

### http协议说一下 

```text
1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
4.http请求信息request：
	请求行（request line）、请求头部（header）,空行和请求数据四部分构成

	请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
	请求头部，用来说明服务器要使用的附加信息
	空行，请求头部后面的空行是必须的
	请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
	状态行、消息报头、空行和响应正文

	状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
	消息报头，用来说明客户端要使用的一些附加信息
	空行，消息报头后面的空行是必须的
	响应正文，服务器返回给客户端的文本信息。
```

### 说一下https和http的区别

```text
https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密
http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少
```

1.  http基于TCP/IP协议，https基于SSL/TLS协议
2.  http默认端口号为80，https默认端口号为443
3.  https安全性更强，需要CA证书
4.  https可以防止运营商劫持

>   可以介绍https的通信过程，涉及对称加密和非对称加密

### 为什么https安全？ 

博客里。

### 那https会不会带来性能问题？ 

### **http请求有哪几种**

**http1.0**：get、post、head

**http1.1**:put、delete、connect、trace、options

**简单请求**:

1.  请求method只能是get、post、head
2.  请求头只能是accept/accept-language/content-language/content-Type
3.  content-Type只能是text/plain、multipart/form-data、application/x-www-form-urlencoded

### **介绍http1.0|http1.1|http2.0**

**http1.0**:

1.  完成连接即断开，导致重新慢启动和三次握手
2.  线头阻塞，导致请求间相互影响

**http1.1**：

1.  用keep-alive支持长连接
2.  用host字段指定对应的虚拟站点
3.  新增功能: 断点续传、身份认证、状态管理、cache缓存->cache-control、expires、last-modified、etag

**http2.0**：

1.  二进制分帧层：应用层和传输层
2.  header头部压缩
3.  服务端推送
4.  多路复用

>   二进制分帧层可以扩展到计算机网络的OSI参考模型

```text
长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接
节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域

1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源
```

### **http状态码**

100-199 用于指定客户端应相应的某些动作。 

200-299 用于表示请求成功。 

300-399 用于已经移动的文件并且常被包含在 定位头信息中指定新的地址信息。

400-499 用于指出客户端的错误。

500-599 用于支持服务器错误。 

```js
200-请求成功
301-永久重定向
302和307-临时重定向
304-读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]
400-当前请求不能被服务器理解或请求参数有误
401-权限不够，请求需要认证或认证失败
403-服务器禁止访问
404-资源未找到
405-方法未允许
500-内部服务器错误
502-网关错误
503-服务不可用、服务器处于超负载或停机维护
```

### **了解nginx吗**

ngnix是个高性能反向代理服务器，有以下作用:

-   解决跨域
-   请求过滤
-   配置gzip
-   负载均衡
-   静态资源服务器

ngnix解决跨域的原理:

-   把后端域名设为前端服务的域名，然后设置相应的location拦截前端需要跨域的请求，最后将请求代理回服务端的域名
-   ngnix实现负载均衡的策略:轮询、最小链接数、最快响应时间

### 知道强缓存和协商缓存吗？说一下 

博客里。

### 说一下协商缓存的详细流程

**web缓存**

```text
1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本
2.缓存的好处
        （1）减少不必要的请求
    （2）降低服务器的压力，减少服务器的消耗
    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）
```

## 性能优化

### 说几条web前端优化策略?

(1). 减少HTTP请求数

这条策略基本上所有前端人都知道，而且也是最重要最有效的。都说要减少HTTP请求，那请求多了到底会怎么样呢？首先，每个请求都是有成本的，既包 含时间成本也包含资源成本。一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个“漫长”而复杂的过程。 时间成本就是用户需要看到或者“感受”到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。

另外，由于浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给 用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。减少HTTP请求数的主要途径包括：

(2). 从设计实现层面简化页面

如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。

(3). 合理设置HTTP缓存

缓存的力量是强大的，恰当的缓存设置可以大大的减少HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出78个请求，共600多K 数据（如图1.1），而当第二次访问即浏览器已缓存之后访问则仅有10个请求，共20多K数据（如图1.2）。（这里需要说明的是，如果直接F5刷新页面 的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是304响应，只有Header没有Body，可以节省带宽）

怎样才算合理设置？原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过HTTP Header中的Expires设置一个很长的过期头；变化不频繁而又可能会变的资源可以使用Last-Modifed来做请求验证。尽可能的让资源能够 在缓存中待得更久。

(4). 资源合并与压缩

如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外，CSS、Javascript、Image都可以用相应的工具进行压缩，压缩后往往能省下不少空间。

(5). CSS Sprites

合并CSS图片，减少请求数的又一个好办法。

(6). Inline Images

使用data: URL scheme的方式将图片嵌入到页面或CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在CSS中的图片则更为理想一些。

(7). Lazy Load Images

这条策略实际上并不一定能减少HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只 加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。有啊首页曾经的做法 是在加载的时候把第一屏之后的图片地址缓存在Textarea标签中，待用户往下滚屏的时候才“惰性”加载。

### 一、webpack打包文件体积过大？（最终打包为一个js文件）

```text
1.异步加载模块
2.提取第三库
3.代码压缩
4.去除不必要的插件
```

### **二、如何优化webpack构建的性能**

```text
一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积
		 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理
		 3.对一些组件库采用按需加载，避免无用的代码
二、减少目录检索范围
		 ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度
	
三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias
```

### 三、移动端的性能优化

```text
  1、首屏加载和按需加载，懒加载
  2、资源预加载
  3、图片压缩处理，使用base64内嵌图片
  4、合理缓存dom对象
  5、使用touchstart代替click（click 300毫秒的延迟）
  6、利用transform:translateZ(0)，开启硬件GUP加速
  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明
  8、使用viewport固定屏幕渲染，加速页面渲染内容
  9、尽量使用事件代理，避免直接事件绑定
```

### 四、Vue的SPA 如何优化加载速度

```text
1.减少入口文件体积
2.静态资源本地缓存
3.开启Gzip压缩
4.使用SSR,nuxt.js
```

### 五、移动端300ms延迟

```text
由来：
300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，
当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作
因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕
       
解决方案：1.禁用缩放，设置meta标签 user-scalable=no
	  2.fastclick.js
		原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即
		      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉
fastclick.js还可以解决穿透问题
```

### 六、页面的重构；

>   在不改变外部行为的前提下，简化结构、添加可读性

## **web安全**

### **常见的web安全及防护原理**

```text
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，
            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，
            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
		防范：1.对用户输入进行校验
		       2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。
		        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
			防范：1.尽量采用post而不使用get提交表单
			      2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
			举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据
			防范：在客服端页面增加伪随机数，通过验证码
XSS和CSRF的区别：
   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包
   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包
```

### **xss**

跨站脚本攻击，指攻击者在网页上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时， 对客户端浏览器进行控制或获取用户隐私数据的方式

**防范**：

1.  httpOnly防止截取cookie
2.  用户输入检查
3.  用户输出检查
4.  利用CSP（浏览器的内容安全策略）

### csrf

跨站请求伪造，劫持受信任用户向服务器发送非预期请求的方式。

**防范**：

1.  验证码
2.  referer check
3.  增加token验证

## 数据结构

在[LeetCode-write](/Users/suntian/codes/webproject/tianguoguoblog.io/_posts/2020-12-09-LeeCode-write.md)里

## 半结构化问答

### 说说你对前端的理解？

### 你说你热爱前端，那么应该 WEB 行业的发展很关注吧？ 说说最近最流行的一些东西吧？

### 你有了解我们公司吗？说说你的认识？

### 作为一名前端工程师，无论工作年头长短都应该必须 掌握的知识点有：

1、DOM 结构 —— 两个节点之间可能存在哪些 关系以及如何在节点之间任意移动。

2、DOM 操作 ——如何添加、移除、移动、复制、 创建和查找节点等。

3、事件 —— 如何使用事件，以及 IE 和标 准 DOM事件模型之间存在的差别。

4、XMLHttpRequest—— 这是什么、怎样完整 地执行一次 GET 请求、怎样检测错误。

5、严格模式与混杂模式 —— 如何触发这两种模 式，区分它们有何意义。

6、盒模型 —— 外边距、内边距和边框之间的关 系，及 IE8 以下版本的浏览器中的盒模型

7、块级元素与行内元素 —— 怎么用 CSS控制 它们、以及如何合理的使用它们

8、浮动元素——怎么使用它们、它们有什么问题 以及怎么解决这些问题。

9、HTML 与 XHTML——二者有什么区别，你觉得应该使用哪一个并说出理由。

10、JSON —— 作用、用途、设计结构。