---
layout:     post           # 使用的布局（不需要改）
title:      前端面经总结
subtitle:   前端面经总结 #副标题
date:       2020-12-14             # 时间
author:     甜果果                    # 作者
header-img: https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@1.0/assets/img/home-bg-art.jpg    #背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 前端
    - 面试

---

# 前端面经知识点总结

## 面试经验

- 面对面语速放慢，眼神坚定，杜绝小动作。
- 来来来，键盘给你，你来写，talk is cheap, show me your code！

## HTML&HTML5

### 浏览器内核？常见的浏览器内核？

**浏览器内核是**浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。 浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。 不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。

**浏览器内核包括两部分**，渲染引擎和js引擎。**渲染引擎**负责读取网页内容，整理讯息，计算网页的显示方式并显示页面，**js引擎**是解析执行js获取网页的动态效果。 后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

**常见的浏览器内核**

IE：Trident 
firefox：Gecko 
Chrome、safari：webkit 
Opera：Presto 
Microsoft Edge：EdgeHTML

### 语义化的理解？

html语义化就是让页面的内容结构化， 便于对浏览器、搜索引擎解析； 

在没有样式 CCS 情况下也以一种文档格式显示，并 且是容易阅读的。 

搜索引擎的爬虫依赖于标记来确定上下文和各个关键 字的权重，利于 SEO。 

使阅读源代码的人对网站更容易将网站分块，便于阅 读维护理解。

### 描述一下你理解的HTML

HTML，超文本标记语言，超文本是因为它可以加入图片、声音、动画、多媒体等内容，还可以从一个文件跳转到另一个文件。

标记语言是一套标记标签，网页是由网页元素组成的 ，这些元素是利用html标签描述出来，然后通过浏览器解析，就可以显示给用户了。

###  XHTML

XHTML 是更严格更纯净的 HTML 代码。

可扩展超文本标签语言（EXtensible HyperText Markup Language）。目标是取代 HTML。是作为一种 XML 应用被重新定义的 HTML。是一个 W3C 标准。

### [HTML常用标签及属性](https://www.jianshu.com/p/57cecb7cfc4c)

#### 1- 链接

```xml
又称超链接，设置页面中允许被点击的内容。
【标签】<a></a>
【属性】
href：链接地址（要跳转到的页面的地址）
target：目标，打开新网页的形式
取值：
     _blank：在新标签页中打开
     _self：在自身页面中打开（默认值）
title：鼠标放到链接上的提示
```

#### 2- 文本标记

-   特殊字符

```jsx
空格： 
<:  <
>:  ≷  
©:  ©
￥: ¥ 
```

-   文本样式

```xml
斜体：<i></i>
粗体：<b></b>
删除线：<s></s>
下划线：<u></u>
上标：<sup></sup>
下标：<sub></sub>
```

-   标题元素

```xml
以标题的形式来显示文本内容
<h1></h1>
<h2></h2>
<h3></h3>
<h4></h4>
<h5></h5>
<h6></h6>
【特点】
- 改变字号（一级最大，六级最小）
- 加粗显示
- 上下有垂直的空白距离
- 独立成行
```

-   段落元素

```xml
【标签】<p></p>
【特点】
- 默认文字大小
- 独立成行
- 上下垂直空白
```

-   换行元素

```xml
【标签】<br>
```

-   分隔线元素

```swift
【标签】<hr>
【属性】
        size：尺寸，取值单位为 px（像素），可以省略
        width：宽度，取值单位为px（像素）可以省略或百分比
        color：颜色，取值自然颜色值
        align：水平对齐方式，取值：left/center/right
```

-   分区元素

```xml
（1）块分区元素：<div></div>
【特点】独立成行
【作用】页面布局
（2）行内分区元素：<span></span>
【特点】多个元素在一行内显示
【作用】设置同一行文字内的不同格式
```

-   行内元素与块级元素

```undefined
（1）块级元素（div 、p、h1~h6）
【特点】元素会独占一行，即元素前后都会自动换行，主要用于网页布局
（2）、行内元素（ span、i、b、s、u、sub、sup、img、a）
【特点】不会换行，多个元素会在一行内显示
```

#### 3- 图像

-   路径

```undefined
URL：Uniform Resource Locator（统一资源定位器，俗称：路径） 
作用：标识网络任何资源的位置

（1）绝对路径：从文件所在的最高级目录下开始查找资源文件所经过的路径
-包括网络资源&本地资源（如：E:\mmper\练习\img\flower.jpg）
（2）相对路径：从当前文件位置处开始，查找资源文件所经过的路径
- 同目录，直接用， 直接通过资源文件名称进行引用（a.jpg）
- 子目录，进入到子目录中，然后再对资源文件进行引用（img/a.jpg）
- 父目录，返回到父级目录再对资源文件进行引用（../a.jpg）
```

-   图像

```xml
【标签】<img>
【属性】
        src：图片地址（绝对/相对）
        width：图像宽度
        height：图像高度
```

#### 4- 表格

```xml
由<table>元素定义。
【标签】<table></table>
【属性】
        width ：设置表格的宽度
        height：设置表格的高度
        align：设置表格的对齐方式，取值: left/center/right
        border：设置表格边框宽度
        cellpadding：内边距（单元格边框与内容之间的距离）
        cellspacing：外边距（单元格之间的距离）
        bgcolor：设置表格的背景颜色
```

-   table中包含的子元素

```xml
<table></table>中包含的子元素：
【标签】<tr></tr> （创建表行）
【属性】
       align：该行内容水平对齐方式，取值: left/center/right
       valign：该行内容的垂直对齐方式，取值: top/middle/bottom
       bgcolor：设置表格的背景颜色

【标签】<td></td> （创建单元格）
【属性】
        align：内容水平对齐方式
        valign：内容垂直对齐方式
        width ：宽度
        height ：高度
【标签】<caption></caption> （表格标题）
【标签】<th></th> （列标题）
        行标题或列标题，字体有加粗的效果，放在tr中
【标签】<thead></thead> （表头）
【标签】<tbody></tbody> 表主体）
【标签】<tfoot></tfoot> （表尾）
```

-   一个完整的表格

```xml
<caption>标题文本</caption>
<table>
   <thead>
    <tr>
      <td>姓名</td>
       <td>性别</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>张三</td>
      <td>男</td>
    </tr>
    <tr>
      <td>李四</td>
      <td>女</td>
    </tr>
  </tbody>
</table>
```

-   两行两列的表格

```xml
<table>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
</table>
```

-   表格的其他应用

```undefined
（1）不规则表格
- 跨列：从指定单元格位置处，横向向右合并几个（包含自己）单元格
  属性：colspan=值（数字，合并单元格的个数）;
- 跨行：从指定单元格位置处，纵向向下合并几个（包含自己）单元格
  属性：rowspan=值（数字，合并单元格的个数）;
（2）表格的嵌套
  在单元格中去嵌套另一个表格，但嵌套的表格必须要放在td中
```

#### 5- 列表

```undefined
将一组具有相似特征或者具有先后顺序的内容按照从上到下的顺序排列在一起
```

-   有序列表

```xml
<ol>
    <li></li>
</ol>
【属性】
        type:指定列表项标志的类型，默认为数字排列
        取值：1（默认值）/a/A/i/I
        start:定义起始值(数字)，默认从1开始
        取值：数字，如：start:1;  start:i;等 
```

-   无序列表

```xml
<ul>
     <li></li>
</ul>
【属性】
        type：指定无序列表的列表项标识
        取值： disc,默认,实心圆/circle，空心圆/square，实心矩形none，不显示标识
```

-   自定义列表

```xml
<dl>
  <dt>列表中的标题内容</dt>
  <dd>列表中的数据</dd>
</dl>
使用场合：图文混排时使用
```

#### 6- 表单

```xml
由<form>定义，将用户输入的数据提交给后台。
【常见属性】
        action：提交的服务器地址
        method：表单数据提交的方式，取值： get：明文提交/post：隐式提交
        name：定义表单名称，JS用到的比较多
        id： 独一无二的标识
如：<form action="url" method="get/post"> </form>
```

<input>元素

```bash
【主要属性】
        type：根据不同的type属性值可以创建各种类型的输入字段
        value：最终提交给服务器的值
        name：控件的名称，提供给服务器使用，没有name，控件则无法提交
        id：唯一标识，只能在当前页面使用，服务器不能用
        disabled：禁用，不能被提交
```

-   常用的表单控件：

```bash
（1）文本框：<input type="text">
（2）密码框：<input type="password">
 【专有属性】
         maxlength：限制输入的字符数，取值：数字
         readonly：设置文本控件只读
（3）单选按钮：<input type="radio">
（4）复选框：<input type="checkbox">
【专有属性】
         checked，设置默认被选中
（5）提交按钮：<input type="submit">
（6）重置按钮：<input type="reset">
（7）普通按钮：<input type="button">
（8）图片按钮：<input type="image" src=""> 
（9）隐藏域：<input type="hidden">
（10）文件选择框：<input type="file">
```

###### 按钮（提交按钮）

```xml
<button>内容</button>
```

###### 下拉选择框select 和 option

```xml
<section name="">
  <option value="" selected></option>
</section>
```

#### 7- 结构标记

```undefined
HTML5所提供的结构标记，专门用于表示常见的网页结构（即制作布局），提升布局代码的语义性和可读性
```

-   常见结构标记

```xml
<header></header>：定义文档的页眉即页面顶部信息
<nav></nav>：定义页面的导航链接部分
<section></section>：定义文档中的节，文档中主体内容
<article></article> ：定义独立于文档的其他部分内容(章、节等)
<footer></footer>：定义某区域的脚注信息，页面底部内容等
<aside></aside>：多用于侧边栏和相关引用信息等
```

### 块元素、内联元素、内联块元素

#### 常用的块状元素有：

```xml
<div>、<p>、<h1>-<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>
```

#### 常用的内联元素有：

```xml
<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>
```

#### 常用的内联块状元素有：

```xml
<img>、<input>
```

#### 空元素有：

```css
<br> <hr><img> <input> <link> <meta>
```

#### 鲜为人知的是:

```css
<area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>
```

### 讲讲盒子模型 

一种是IE盒模型，一种是W3C标准盒模型

**IE盒子模型** 宽度=内容宽度+padding *2+border *2

**w3c盒子模型** 宽度=内容宽度

可以通过box-sizing切换，默认为content-box(w3c盒子模型)，设置border-box时为IE盒子模型

盒模型： 内容(content)、填充(padding)、 边界(margin)、 边框(border).

### doctype作用，严格模式和混合模式的区别

（1）、<!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档。

（2）、严格模式的排版和 JS 运作模式是 浏览器支持的最高标准运行。

以该

（3）、在混杂模式中，页面以宽松的向后兼容的 方式显示。模拟老式浏览器的行为以防止站点无法工 作。

（4）、DOCTYPE不存在或格式不正确会导致文 档以混杂模式呈现。

### [H5新特性：十个新特性](https://www.cnblogs.com/jane-panyiyun/p/13092297.html)

一、语义标签

二、增强型表单

三、视频和音频

四、Canvas绘图

五、SVG绘图

六、地理定位

七、拖放API

八、WebWorker

九、WebStorage

十、WebSocket

**一、语义标签**

html5语义标签，可以使开发者更方便清晰构建页面的布局

| 标签      | 描述                               |
| --------- | ---------------------------------- |
| <header>  | 定义了文档的头部区域               |
| <footer>  | 定义了文档的尾部区域               |
| <nav>     | 定义文档的导航                     |
| <section> | 定义文档中的节                     |
| <article> | 定义文章                           |
| <aside>   | 定义页面以外的内容                 |
| <details> | 定义用户可以看到或者隐藏的额外细节 |
| <summary> | 标签包含details元素的标题          |
| <dialog>  | 定义对话框                         |
| <figure>  | 定义自包含内容，如图表             |
| <main>    | 定义文档主内容                     |
| <mark>    | 定义文档的主内容                   |
| <time>    | 定义日期/时间                      |

**二、增强型表单**

html5修改一些新的input输入特性，改善更好的输入控制和验证

| 输入类型       | 描述                     |
| -------------- | ------------------------ |
| color          | 主要用于选取颜色         |
| date           | 选取日期                 |
| datetime       | 选取日期(UTC时间)        |
| datetime-local | 选取日期（无时区）       |
| month          | 选择一个月份             |
| week           | 选择周和年               |
| time           | 选择一个时间             |
| email          | 包含e-mail地址的输入域   |
| number         | 数值的输入域             |
| url            | url地址的输入域          |
| tel            | 定义输入电话号码和字段   |
| search         | 用于搜索域               |
| range          | 一个范围内数字值的输入域 |

html5新增了五个表单元素

| <datalist> | 用户会在他们输入数据时看到域定义选项的下拉列表 |
| ---------- | ---------------------------------------------- |
| <progress> | 进度条，展示连接/下载进度                      |
| <meter>    | 刻度值，用于某些计量，例如温度、重量等         |
| <keygen>   | 提供一种验证用户的可靠方法生成一个公钥和私钥   |
| <output>   | 用于不同类型的输出比如尖酸或脚本输出           |

html5新增表单属性

| 属性         | 描述                                  |
| ------------ | ------------------------------------- |
| placehoder   | 输入框默认提示文字                    |
| required     | 要求输入的内容是否可为空              |
| pattern      | 描述一个正则表达式验证输入的值        |
| min/max      | 设置元素最小/最大值                   |
| step         | 为输入域规定合法的数字间隔            |
| height/wdith | 用于image类型<input>标签图像高度/宽度 |
| autofocus    | 规定在页面加载时，域自动获得焦点      |
| multiple     | 规定<input>元素中可选择多个值         |

**三、音频和视频**

html5提供了音频和视频文件的标准，既使用<audio>元素。

音频：<audio src=" "></audio>

```
<audio controls>    //controls属性提供添加播放、暂停和音量控件。
  <source src="horse.ogg" type="audio/ogg">
  <source src="horse.mp3" type="audio/mpeg">
您的浏览器不支持 audio 元素。        //浏览器不支持时显示文字
</audio>
```

视频：<video src=" "></video>

```
<video width="320" height="240" controls>
  <source src="movie.mp4" type="video/mp4">
  <source src="movie.ogg" type="video/ogg">
您的浏览器不支持Video标签。
</video>
```

**四、Canvas绘图**

[https://www.runoob.com/w3cnote/html5-canvas-intro.html ](https://www.runoob.com/w3cnote/html5-canvas-intro.html)

**五、SVG绘图**

什么是SVG?

 SVG指可伸缩矢量图形

 SVG用于定义用于网络的基于矢量的图形

 SVG使用XML格式定义图形

 SVG图像在放大或改变尺寸的情况下其图形质量不会有损失

 SVG是万维网联盟的标准

SVG的优势

与其他图像格式相比，是哟个SVG的优势在于：

  SVG图像可通过文本编译器来创建和修改

  SVG图像可被搜索、索引、脚本化或压缩

  SVG是可伸缩的

  SVG图像可在任何的分辨率下被高质量的打印

  SVG可在图像质量不下降的情况下被放大

SVG与Canvas区别

*SVG适用于描述XML中的2D图形的语言

*Canvas随时随地绘制2D图形（使用javaScript）

*SVG是基于XML的，意味这可以操作DOM，渲染速度较慢

*在SVG中每个形状都被当做是一个对象，如果SVG发生改变，页面就会发生重绘

*Canvas是一像素一像素地渲染，如果改变某一个位置，整个画布会重绘。

| Canvas                           | SVG                        |
| -------------------------------- | -------------------------- |
| 依赖分辨率                       | 不依赖分辨率               |
| 不支持事件处理器                 | 支持事件处理器             |
| 能够以.png或.jpg格式保存结果图像 | 复杂度会减慢搞渲染速度     |
| 文字呈现功能比较简单             | 适合大型渲染区域的应用程序 |
| 最合适图像密集的游戏             | 不适合游戏应用             |

**六、地理定位**

使用getCurrentPosition()方法来获取用户的位置。以实现“LBS服务”

```js
<script>
var x=document.getElementById("demo");
function getLocation()
  {
  if (navigator.geolocation)
    {
    navigator.geolocation.getCurrentPosition(showPosition);
    }
  else{x.innerHTML="Geolocation is not supported by this browser.";}
  }
function showPosition(position)
  {
  x.innerHTML="Latitude: " + position.coords.latitude +
  "<br />Longitude: " + position.coords.longitude;
  }
</script>
```

**七、拖放API**

 拖放是一种常见的特性，即捉取对象以后拖到另一个位置。

在html5中，拖放是标准的一部分，任何元素都能够拖放。

```
<div draggable="true"></div>
```

当元素拖动时，我们可以检查其拖动的数据。

```
<div draggable="true" ondragstart="drag(event)"></div>
<script>
function drap(ev){
    console.log(ev);
}
</script>
```

| 拖动生命周期 | 属性名      | 描述                                           |
| ------------ | ----------- | ---------------------------------------------- |
| 拖动开始     | ondragstart | 在拖动操作开始时执行脚本                       |
| 拖动过程中   | ondrag      | 只要脚本在被拖动就运行脚本                     |
| 拖动过程中   | ondragenter | 当元素被拖动到一个合法的防止目标时，执行脚本   |
| 拖动过程中   | ondragover  | 只要元素正在合法的防止目标上拖动时，就执行脚本 |
| 拖动过程中   | ondragleave | 当元素离开合法的防止目标时                     |
| 拖动结束     | ondrop      | 将被拖动元素放在目标元素内时运行脚本           |
| 拖动结束     | ondragend   | 在拖动操作结束时运行脚本                       |

**八、Web Worker**

  Web Worker可以通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行。

 基本使用：

   Web Worker的基本原理就是在当前javascript的主线程中，使用Worker类加载一个javascript文件来开辟一个新的线程，

起到互不阻塞执行的效果，并且提供主线程和新县城之间数据交换的接口：postMessage、onmessage。

javascript:

```
//worker.js
onmessage =function (evt){
  var d = evt.data;//通过evt.data获得发送来的数据
  postMessage( d );//将获取到的数据发送会主线程
}
```

```
<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script type="text/javascript">
//WEB页主线程
var worker =new Worker("worker.js"); //创建一个Worker对象并向它传递将在新线程中执行的脚本的URL
worker.postMessage("hello world");     //向worker发送数据
worker.onmessage =function(evt){     //接收worker传过来的数据函数
   console.log(evt.data);              //输出worker发送来的数据
}
</script>
</head>
<body></body>
</html>
```

**九、Web Storage**

 WebStorage是HTML新增的本地存储解决方案之一，但并不是取代cookie而指定的标准，cookie作为HTTP协议的一部分用来处理客户端和服务器的通信是不可或缺的，session正式依赖与实现的客户端状态保持。WebSorage的意图在于解决本来不应该cookie做，却不得不用cookie的本地存储。

websorage拥有5M的存储容量，而cookie却只有4K，这是完全不能比的。

客户端存储数据有两个对象，其用法基本是一致。

localStorage：没有时间限制的数据存储

sessionStorage:在浏览器关闭的时候就会清除。

```
localStorage.setItem(key,value);//保存数据
    let value = localStorage.getItem(key);//读取数据
    localStorage.removeItem(key);//删除单个数据
    localStorage.clear();//删除所有数据
    let key = localStorage.key(index);//得到某个索引的值
```

**十、WebSocket**

  WebSocket协议为web应用程序客户端和服务端之间提供了一种全双工通信机制。

特点：

 （1）握手阶段采用HTTP协议，默认端口是80和443

 （2）建立在TCP协议基础之上，和http协议同属于应用层

 （3）可以发送文本，也可以发送二进制数据。

 （4）没有同源限制，客户端可以与任意服务器通信。

 （5）协议标识符是ws（如果加密，为wss），如ws://localhost:8023

###  [BFC的理解、触发 BFC](https://zhuanlan.zhihu.com/p/25321647)

一、常见定位方案

在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:

-   普通流 (normal flow)

>   在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。

-   浮动 (float)

>   在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。

-   绝对定位 (absolute positioning)

>   在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。

二、BFC 概念

BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。

**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

三、触发 BFC

只要元素满足下面任一条件即可触发 BFC 特性：

-   body 根元素
-   浮动元素：float 除 none 以外的值
-   position：absolute或fixed
-   display 为 inline-block、table-cells、flex
-   overflow 除了 visible 以外的值 (hidden、auto、scroll)

应用:

-   防止垂直方向margin重叠
-   不和浮动元素重叠
-   清除元素内部浮动

### 三栏布局多种实现

三栏布局，顾名思义就是两边固定，中间自适应。

七种方法：

#### 1. 流体布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    background-color: blue;
	    float: right;
	}
	.main {
	    margin-left: 120px;
	    margin-right: 220px;
	    height: 200px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```

左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应。

缺点就是主要内容无法最先加载，当页面内容较多时会影响用户体验。

#### 2. BFC 三栏布局

BFC 规则有这样的描述：BFC 区域，不会与浮动元素重叠。因此我们可以利用这一点来实现 3 列布局。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    margin-right: 20px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    float: right;
	    margin-left: 20px;
	    background-color: blue;
	}	
	.main {
	    height: 200px;
	    overflow: hidden;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```

缺点跟方法一类似，主要内容模块无法最先加载，当页面中内容较多时会影响用户体验。因此为了解决这个问题，有了下面要介绍的布局方案双飞翼布局。

#### 3. 双飞翼布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .content {
  	    float: left;
  	    width: 100%;
        }
        .main {
  	    height: 200px;
  	    margin-left: 110px;
  	    margin-right: 220px;
  	    background-color: green;
        }
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    margin-left: -100%;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    float: right;
	    margin-left: -200px;
	    background-color: blue;
	}	
    </style>
</head>
<body>
    <div class="content">
        <div class="main"></div>
    </div>
    <div class="left"></div>
    <div class="right"></div>
</body>
</html>
```

利用的是浮动元素 margin 负值的应用，感兴趣的同学可以上网搜搜原理。

主体内容可以优先加载，HTML 代码结构稍微复杂点。

#### 4. 圣杯布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    margin-left: 120px;
	    margin-right: 220px;
	}
	.main {
	    float: left;
	    width: 100%;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    float: left;
	    width: 100px;
	    height: 300px;
	    margin-left: -100%;
	    position: relative;
	    left: -120px;
	    background-color: blue;
	}
	.right {
	    float: left;
	    width: 200px;
	    height: 300px;
	    margin-left: -200px;
	    position: relative;
	    right: -220px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```

跟双飞翼布局很像，有一些细节上的区别，相对于双飞翼布局来说，HTML 结构相对简单，但是样式定义就稍微复杂，也是优先加载内容主体。

#### 5. Flex 布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
            display: flex;
	}
	.main {
            flex-grow: 1;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    order: -1;
	    flex: 0 1 200px;
	    margin-right: 20px;
	    height: 300px;
	    background-color: blue;
	}
	.right {
	    flex: 0 1 100px;
            margin-left: 20px;
	    height: 300px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```

简单实用，未来的趋势，需要考虑浏览器的兼容性。

#### 6. Table 布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container {
	    display: table;
	    width: 100%;
        }
        .left, .main, .right {
	    display: table-cell;
        }
        .left {
	    width: 200px;
	    height: 300px;
	    background-color: red;
        }
        .main {
	    background-color: blue;
        }
        .right {
	    width: 100px;
	    height: 300px;
	    background-color: green;
        }
    </style>
</head>
<body>
    <div class="container">
	<div class="left"></div>
	<div class="main"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```

缺点：无法设置栏间距

#### 7. 绝对定位布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    position: relative;
	}
	.main {
	    height: 400px;
	    margin: 0 120px;
	    background-color: green;
	}
	.left {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    left: 0;
	    top: 0;
	    background-color: red;
	}
	.right {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    background-color: blue;
            right: 0;
	    top: 0;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```

### 自适应布局rem原理(如何兼容不同手机dpi)

响应式设计与自适应设计的区别：

响应式开发一套界面，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容；

自适应需要开发多套界面，通过检测视口分辨率，来判断当前访问的设备是pc端、平板、手机，从而请求服务层，返回不同的页面。

**rem响应式的布局思想：**

-   一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值
-   高度值可以设置固定值，设计稿有多大，我们就严格有多大
-   所有设置的固定值都用`rem`做单位（首先在HTML总设置一个基准值：`px`和`rem`的对应比例，然后在效果图上获取`px`值，布局的时候转化为`rem`值)
-   js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了

[前端响应式布局原理与方案（详细版）](https://juejin.cn/post/6844903814332432397)

### [input和textarea的区别](https://www.jianshu.com/p/a72bb81703b7)

一个是用input标签的单行文本框，一种是textarea标签多行文本框。那我们来看看他们的区别：

#### input标签

1、需要指定type属性，如text，password等。

2、通过size属性指定显示字符的长度。

3、value属性指定初始值

4、Maxlength属性指定文本框可以输入的最长长度。

5、焦点垂直居中文本框中，单行

#### textarea标签

1、需要</textarea>来封闭标签

2、内容写在标签对中

3、使用row、col指定textarea大小

4、焦点在左上角，多行

### [用一个div模拟textarea的实现](https://www.jianshu.com/p/a72bb81703b7)

```html
<style>
    #textarea {
        width: 300px;
        min-height: 120px;
        max-width: 300px;
        border: 1px solid #333;
        overflow-y: auto;
    }
</style>

<body>
    <div id='textarea' contenteditable="true"></div>
</body>
```

### html5、CSS3有哪些新特性、移除了那些元素？

语义化标签、媒体元素、存储、表单

1. header、nav、artivale、section、aside、footer

2.  audio和video

Audio：

-   格式：Ogg、MP3、WAV   
-   属性：autoplay、controls、loop、src

video：

-   格式：Ogg、MPEG4、webm
-   属性：autoplay、controls、width、height、loop、preload、src、poster、muted

3.  localStorage和sessionStorage

    本地离线存储 localStorage 长期存储数据，浏览 器关闭后数据不丢失； 

    sessionStorage 的数据在浏览器关闭后自动删除

4.  表单控件，calendar、date、time、email、url、 search



CSS3 实现圆角，阴影，对文字加特效，增加了更 多的 CSS 选择器 多背景 rgba

### HTML5的离线存储 cookie,sesssionStorage,LocalStorage

localStorage 长期存储数据，浏览器关闭后数据不丢失； 

sessionStorage 数据在浏览器关闭后自动删除。 

| 特性           | Cookie                                                       | localStorage                                                | sessionStorage                               |
| -------------- | ------------------------------------------------------------ | ----------------------------------------------------------- | -------------------------------------------- |
| 数据的生命期   | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存                                    | 仅在当前会话下有效，关闭页面或浏览器后被清除 |
| 存放数据大小   | 4K左右                                                       | 一般为5MB                                                   | 5MB左右                                      |
| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信          |                                              |
| 易用性         | 需要程序员自己封装，源生的Cookie接口不友好                   | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                                              |

### 移动web开发之流式布局

视口viewport、布局视口 layout viewport、视觉视口 visual viewport、理想视口 ideal viewport、meta标签

```html
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maxinum-scale=1.0, minimum-scale=1.0">
```

二倍图（物理像素和物理像素比，是因为屏幕大小和手机大小不一样）

CSS初始化 normalize.css

流式布局：

流式布局，就是百分比布局，也称非固定像素布局。

通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。

**京东首页.html**

### 移动web开发之flex布局

父项常见属性

+ flex-direction：设置主轴的方向 row、row-reverse、column、column-reverse
+ justify-content：设置主轴上的子元素排列方式 flex-start、flex-end、center、space-around、space-between
+ flex-wrap：设置子元素是否换行  nowrap、wrap
+ align-content：设置侧轴上的子元素的排列方式（多行）flex-start、flex-end、center、space-around、space-between、stretch
+ align-items：设置侧轴上的子元素排列方式（单行）flex-start、flex-end、center、stretch
+ flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap

**携程首页.html**

### 移动web开发之rem布局

**rem：**

rem (root em)是一个相对单位，类似于em，em是父元素字体大小。

不同的是rem的基准是相对于html元素的字体大小。

比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。

**媒体查询：**

媒体查询（Media Query）是CSS3新语法。

```css
@media mediatype and|not|only (media feature) {
    CSS-Code;
}
```

-   mediatype 查询类型：all、print、screen
-   关键字：and、not、only
-   媒体特性：width、min-width、max-width

**less：**

Less（LeanerStyle Sheets 的缩写）是一门 CSS扩展语言，也成为CSS预处理器。

它在CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。

常见的CSS预处理器：Sass、Less、Stylus

**rem适配方案：**

1.less+rem+媒体查询

2.lflexible.js+rem

```
方案一：
①假设设计稿是750px
②假设我们把整个屏幕划分为15等份（划分标准不一可以是20份也可以是10等份）
③每一份作为html字体大小，这里就是50px
④那么在320px设备的时候，字体大小为320/15就是  21.33px
⑤用我们页面元素的大小除以不同的 html字体大小会发现他们比例还是相同的
⑥比如我们以750为标准设计稿
⑦一个100*100像素的页面元素在  750屏幕下，  就是 100/ 50  转换为rem  是  2rem*2rem  比例是1比1
⑧320屏幕下，  html字体大小为21.33   则 2rem=  42.66px  此时宽和高都是 42.66  但是宽和高的比例还是 1比1
⑨但是已经能实现不同屏幕下  页面元素盒子等比例缩放的效果
```

**苏宁首页.html**

### 移动web开发之响应式布局

就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。

响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。

原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。

Bootstrap、bootstrap栅格系统

**阿里百秀首页.html**



## CSS&CSS3

### 页面重构怎么操作？

编写 CSS、让页面结构更合理化， 提升用户体验，实 现良好的页面效果和提升性能。

### 为什么要初始化 CSS 样式。

因为浏览器的兼容问题，不同浏览器对有些标签的默

认值是不同的，如果没对 CSS 初始化往往会出现浏览 器之间的页面显示差异。

最简单的初始化方法就是： * {padding: 0; margin: 0;}

### CSS的三种样式

| 样式表     | 优点                     | 缺点                     | 使用情况       | 控制范围           |
| ---------- | ------------------------ | ------------------------ | -------------- | ------------------ |
| 行内样式表 | 书写方便，权重高         | 没有实现样式和结构相分离 | 较少           | 控制一个标签（少） |
| 内部样式表 | 部分结构和样式相分离     | 没有彻底分离             | 较多           | 控制一个页面（中） |
| 外部样式表 | 完全实现结构和样式相分离 | 需要引入                 | 最多，强烈推荐 | 控制整个站点（多） |

### CSS 选择符有哪些？哪些属性可以继承？优先级 算法如何计算？ CSS3新增伪类有那些？

标签的权重为 1，class 的权重 为 10， id 的权重为 100。

1.id选择器（ # myid）

2.类选择器（.myclassname）

3.标签选择器（div, h1, p）

4.相邻选择器（h1 + p）

5.子选择器（ul < li）

6.后代选择器（li a）

7.通配符选择器（ * ）

8.属性选择器（a[rel = "external"]）

9.伪类选择器（a: hover, li: nth - child）

可继承： font-size font-family color, UL LI DL DD DT;

不可继承 ：border paddingmarginwidth height ;

优先级就近原则，样式定义最近者为准;

载入样式以最后载入的定位为准; 优先级为:!important > id > class > tag

CSS3新增伪类举例：

-   p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。 
-   p:last-of-type 选择属于其父元素的最后 <p> 元素的每个 <p> 元素。 
-   p:only-of-type 选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。 
-   p:only-child 选择属于其父元素的唯一子元 素的每个 <p> 元素。
-   p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。
-   :enabled、:disabled 控制表单控件的禁用状 态。 
-   :checked， 单选框或复选框被选中。



### font及CSS外观属性总结

选择器 { font: font-style  font-weight  font-size/line-height  font-family;}

| 属性            | 表示     | 注意点                                                  |
| :-------------- | :------- | :------------------------------------------------------ |
| color           | 颜色     | 我们通常用  十六进制   比如 而且是简写形式 #fff         |
| line-height     | 行高     | 控制行与行之间的距离                                    |
| text-align      | 水平对齐 | 可以设定文字水平的对齐方式                              |
| text-indent     | 首行缩进 | 通常我们用于段落首行缩进2个字的距离   text-indent: 2em; |
| text-decoration | 文本修饰 | 记住 添加 下划线  underline  取消下划线  none           |

### CSS复合选择器总结

| 选择器         | 作用                     | 特征                 | 使用情况 | 隔开符号及用法                          |
| -------------- | ------------------------ | -------------------- | -------- | --------------------------------------- |
| 后代选择器     | 用来选择元素后代         | 是选择所有的子孙后代 | 较多     | 符号是**空格** .nav a                   |
| 子代选择器     | 选择 最近一级元素        | 只选亲儿子           | 较少     | 符号是**>**   .nav>p                    |
| 交集选择器     | 选择两个标签交集的部分   | 既是 又是            | 较少     | **没有符号**  p.one                     |
| 并集选择器     | 选择某些相同样式的选择器 | 可以用于集体声明     | 较多     | 符号是**逗号** .nav, .header            |
| 链接伪类选择器 | 给链接更改状态           |                      | 较多     | 重点记住 a{} 和 a:hover  实际开发的写法 |

### 三种标签显示模式display总结区别

| 元素模式   | 元素排列               | 设置样式               | 默认宽度         | 包含                     |
| ---------- | ---------------------- | ---------------------- | ---------------- | ------------------------ |
| 块级元素   | 一行只能放一个块级元素 | 可以设置宽度高度       | 容器的100%       | 容器级可以包含任何标签   |
| 行内元素   | 一行可以放多个行内元素 | 不可以直接设置宽度高度 | 它本身内容的宽度 | 容纳文本或则其他行内元素 |
| 行内块元素 | 一行放多个行内块元素   | 可以设置宽度和高度     | 它本身内容的宽度 |                          |

### CSS背景总结

| 属性                  | 作用             | 值                                                           |
| --------------------- | :--------------- | :----------------------------------------------------------- |
| background-color      | 背景颜色         | 预定义的颜色值/十六进制/RGB代码                              |
| background-image      | 背景图片         | url(图片路径)                                                |
| background-repeat     | 是否平铺         | repeat/no-repeat/repeat-x/repeat-y                           |
| background-position   | 背景位置         | length/position    分别是x  和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法 |
| background-attachment | 背景固定还是滚动 | scroll/fixed                                                 |
| 背景简写              | 更简单           | 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;  他们没有顺序 |
| 背景透明              | 让盒子半透明     | background: rgba(0,0,0,0.3);   后面必须是 4个值              |

### CSS优先级 权重计算公式

```text
不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性
	1.属性后面加!import 会覆盖页面内任何位置定义的元素样式
	2.作为style属性写在元素内的样式
	3.id选择器
	4.类选择器
	5.标签选择器
	6.通配符选择器（*）
	7.浏览器自定义或继承
**同一级别：后写的会覆盖先写的**
```

>   css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素

| 标签选择器             | 计算权重公式 |
| ---------------------- | ------------ |
| 继承或者 *             | 0,0,0,0      |
| 每个元素（标签选择器） | 0,0,0,1      |
| 每个类，伪类           | 0,0,1,0      |
| 每个ID                 | 0,1,0,0      |
| 每个行内样式 style=""  | 1,0,0,0      |
| 每个!important  重要的 | ∞ 无穷大     |

### CSS属性书写顺序

建议遵循以下顺序：

1. 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）
2. 自身属性：width / height / margin / padding / border / background
3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word
4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …

```css
.jdc {
    display: block;
    position: relative;
    float: left;
    width: 100px;
    height: 100px;
    margin: 0 10px;
    padding: 20px 0;
    font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
    color: #333;
    background: rgba(0,0,0,.5);
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
```



### **CSS中 link 和@import 的区别是？**

（1）、link 属于 XHTML标签， 而@import是 CSS提供的;

（2）、页面被加载的时，link会同时被加载，而 @import引用的 CSS会等到页面被加载完再加载;

（3）、import 只在 IE5 以上才能识别，而 link 是 XHTML标签，无兼容问题;

（4）、link 方式的样式的权重 高于@import 的权重.

### position的四个属性值 

Static  relative  fixed  absolute  sticky CSS 定位详解

### position的值， relative和 absolute定位原点是？

- absolute 生成绝对定位的元素，相对于 static 定位以 外的第一个父元素进行定位。
- fixed （老 IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行 定位。
- relative 生成相对定位的元素，相对于其正常位置进行 定位。

* static默认值。没有定位，元素出现在正常的流中
* inherit 规定从父元素继承

### 列出 display的值，说明他们的作用。

1.  block 象块类型元素一样显示。
2.  none 缺省值。向行内元素类型一样显示。 
3.  inline-block 象行内元素一样显示，但其内容象块 类型元素一样显示。 
4.  list-item 象块类型元素一样显示，并添加样式列表 标记。

### 显示与隐藏display visibility overflow

| 属性           | 区别                   | 用途                                                         |
| -------------- | ---------------------- | ------------------------------------------------------------ |
| **display**    | 隐藏对象，不保留位置   | 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 |
| **visibility** | 隐藏对象，保留位置     | 使用较少                                                     |
| **overflow**   | 只是隐藏超出大小的部分 | 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围      |

### text-overflow 文字溢出

```css
  /*1. 先强制一行内显示文本*/
      white-space: nowrap;
  /*2. 超出的部分隐藏*/
      overflow: hidden;
  /*3. 文字用省略号替代超出的部分*/
      text-overflow: ellipsis;
```

### **雪碧图**

**为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。**

```text
多个图片集成在一个图片中的图
使用雪碧图可以减少网络请求的次数，加快允许的速度
通过background-position，去定位图片在屏幕的哪个位置
```

### 用CSS实现三角的效果？

![image-20201211092544349](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201211092544.png)

```css
div {
            width: 0;
            height: 0;
            line-height: 0;
            font-size: 0;
            border-top: 10px solid red;
            border-right: 10px solid green;
            border-bottom: 10px solid blue;
            border-left: 10px solid #000;
        }
```

1. 我们用css 边框可以模拟三角效果
2. 宽度高度为0
3. 我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了
4. 为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;

### 实现九宫格

5种方法

#### 1. FlexBox

HTML 结构如下：

```
<div class="square">
  <ul class="square-inner flex">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
    <li>7</li>
    <li>8</li>
    <li>9</li>
  </ul>
</div>
```

抽取公共样式：

```
.square{
  position: relative;
  width: 100%;
  height: 0;
  padding-bottom: 100%; /* padding百分比是相对父元素宽度计算的 */
  margin-bottom: 30px;
}
.square-inner{
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%; /* 铺满父元素容器，这时候宽高就始终相等了 */
}
.square-inner>li{
  width: calc(98% / 3);  /* calc里面的运算符两边要空格 */
  height: calc(98% / 3);
  margin-right: 1%;
  margin-bottom: 1%;
  overflow: hidden;
}
```

使用Flex的一个好处是不用再担心高度塌陷的问题，而且还可以轻松实现子元素横向竖向甚至按比例伸缩扩展的布局。

```
.flex{
  display: flex;
  flex-wrap: wrap;
}
.flex>li{
  flex-grow: 1; /* 子元素按1/n的比例进行拉伸 */
  background-color: #4d839c;
  text-align: center;
  color: #fff;
  font-size: 50px;
  line-height: 2;
}
.flex>li:nth-of-type(3n){ /* 选择个数是3的倍数的元素 */
  margin-right: 0;
}
.flex>li:nth-of-type(n+7){  /* 选择倒数的三个元素，n可以取0 */
  margin-bottom: 0;
}
```

[![17_12_08_01.png](https://i.loli.net/2017/12/08/5a2a6c7ca0c88.png)](https://i.loli.net/2017/12/08/5a2a6c7ca0c88.png)

[FlexBox-效果图](https://i.loli.net/2017/12/08/5a2a6c7ca0c88.png)

#### 2. Grid

对于网格布局来说，grid 比 flex 更为方便，代码量更少，可以处理更为复杂的结构。

```
<div class="square">
  <div class="square-inner grid">
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <div>6</div>
    <div>7</div>
    <div>8</div>
    <div>9</div>
  </div>
</div>
.grid{
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* 相当于 1fr 1fr 1fr */
  grid-template-rows: repeat(3, 1fr); /* fr单位可以将容器分为几等份 */
  grid-gap: 1%; /* grid-column-gap 和 grid-row-gap的简写 */
  grid-auto-flow: row;
}
.grid>div{
  color: #fff;
  font-size: 50px;
  line-height: 2;
  text-align: center;
  background: linear-gradient(to bottom, #f5f6f6 0%,#dbdce2 21%,#b8bac6 49%,#dddfe3 80%,#f5f6f6 100%);
}
```

[![17_12_08_05.png](https://i.loli.net/2017/12/10/5a2cf18e48460.png)](https://i.loli.net/2017/12/10/5a2cf18e48460.png)

[Grid-效果图](https://i.loli.net/2017/12/10/5a2cf18e48460.png)



更多：[CSS Grid布局指南](http://blog.csdn.net/ceshi986745/article/details/51733383)

#### 3. Float

浮动实现九宫格就不多说了，原理同上。

```
<div class="square">
  <ul class="square-inner float">
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
    <li>7</li>
    <li>8</li>
    <li>9</li>
  </ul>
</div>
.float::after{
  content: "";
  display: block;
  clear: both;
  visibility: hidden;
}
.float>li{
  float: left;
  background-color: #42a59f;
  text-align: center;
  color: #fff;
  font-size: 50px;
  line-height: 2;
}
.float>li:nth-of-type(3n){
  margin-right: 0;
}
.float>li:nth-of-type(n+7){
  margin-bottom: 0;
}
```

[![17_12_08_02.png](https://i.loli.net/2017/12/08/5a2a6c7ca6312.png)](https://i.loli.net/2017/12/08/5a2a6c7ca6312.png)

[Float-效果图](https://i.loli.net/2017/12/08/5a2a6c7ca6312.png)



除了浮动，这里 li 也可以使用`display: inline-block;`实现同样的效果，不过要注意HTML代码非压缩情况下行块级元素之间会出现默认间隔，不同浏览器下表现还不一样，这时可以给父级元素设置`font-size: 0;`

#### 4. Table

```
<div class="square">
  <table class="square-inner table">
    <tbody>
      <tr>
        <td>1</td>
        <td>2</td>
        <td>3</td>
      </tr>
      <tr>
        <td>4</td>
        <td>5</td>
        <td>6</td>
      </tr>
      <tr>
        <td>7</td>
        <td>8</td>
        <td>9</td>
      </tr>
    </tbody>
  </table>
</div>
.table{
  border-collapse: separate;
  border-spacing: 0.57em;
  font-size: 14px;
  empty-cells: hide;
  table-layout: fixed;
}
.table>tbody>tr>td{
  text-align: center;
  background-color: #889ed8;
  overflow: hidden;
}
```

[![17_12_08_03.png](https://i.loli.net/2017/12/08/5a2a6c7cab47a.png)](https://i.loli.net/2017/12/08/5a2a6c7cab47a.png)

[Table-效果图](https://i.loli.net/2017/12/08/5a2a6c7cab47a.png)



说下用表格实现九宫格有哪些瑕疵：

-   最后一行最后一列的单元格宽高与前面的不一致，虽然相差不大，但是还是有差异的；
-   与前面的两种方法不同，table 单元格之间的间隔是利用`border-spacing`属性实现的，且不支持百分比，单元格四周都有类似margin的外边距效果，如下图。

[![17_12_08_04.png](https://i.loli.net/2017/12/08/5a2a7142123ad.png)](https://i.loli.net/2017/12/08/5a2a7142123ad.png)

[浏览器渲染效果图](https://i.loli.net/2017/12/08/5a2a7142123ad.png)

#### 分析

综上来看，个人认为 FlexBox 适合用于移动端，PC端 IE10 以下不支持；Grid网格布局比较方便，但是规范还未成熟，主流浏览器厂商尚未推广，不推荐使用在项目中；浮动和行块级式声明可以兼容到IE6，移动端和PC端支持的都不错；Table 因为实现有瑕疵所以不推荐使用。

### 如何让一个div水平居中？

已知宽度，block元素 ，添加添加margin:0 auto属性。
已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto

### **如何让一个div水平垂直居中**

```css
//方法一:display: flex-box
display:flex;
justify-content:center;
align-items:center;

//方法二:display:table 
display:table;
vertical-align:center;

//方法五:display:inline-block
//适用于行内元素
display:inline-block;
width:100px;
height:100px;
text-align:center;
line-height:100px;

//方法六:适用于块级元素
display:block;
height:100px;
margin:0 auto;
line-height:100px;

//方法三:适用于已知宽高且父元素定位不为static
postion:absolute;
width:100px;
height:100px;
top:50%;
left:50%;
margin:-50px 0 0 -50px;

//方法四
position:absolute;
top:50%;
left:50%;
transform:translateY(-50%) translateX(-50%);
```

### CSS3属性选择器、结构伪类选择器、伪元素选择器

![image-20201211094710329](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201211094710.png)

```css
input[type=search] {color: skyblue;}
span[class^=black] {color: lightgreen;}
span[class$=black] {color: lightsalmon;}
span[class*=black] {color: lightseagreen;}
```

![image-20201211094806022](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201211094806.png)

```css
ul li:first-child {background-color: lightseagreen;}
ul li:last-child {background-color: lightcoral;}
ul li:nth-child(3) {background-color: aqua;}
```

![image-20201211094940823](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201211094941.png)

### CSS3 2D 3D转换

缩放：scale 移动：translate 旋转：rotate 倾斜：skew

```css
transform: translate(x,y);
transform: rotate(angle);
transform: scale(x,y);
```

-   transform:translate3d(x,y,z)、translform:translateX(100px)、translform:translateY(100px)、translform:translateZ(100px)
-   transform:rotateX(45deg)、transform:rotateY(45deg) 、transform:rotateZ(45deg)、transform:rotate3d(x,y,z,deg)：

透视 perspective

左手准则。

### CSS3动画

```css
animation：动画名称 动画时间 运动曲线 何时开始 播放次数 是否反方向 动画等待或者结束的状态;
animation: myfirst 5s linear 2s infinite alternate;
```

![image-20201211095447319](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201211095447.png)

### **img中alt和title的区别**

>   图片中的 title属性是在鼠标在移动到元素上的文本提示。
>
>   图片中的 alt属性是在图片不能正常显示时出现的文本提示。alt有利于SEO优化

### css3的属性有哪些 

##### CSS3边框

border-radius 圆角边框、box-shadow 边框阴影、border-image 边框图片

##### CSS3背景

background-clip 规定背景的绘制区域、background-origin 规定 background-position 属性相对于什么位置来定、background-size 规定背景图像的尺寸

##### CSS3文本

text-overflow 规定当文本溢出包含元素时发生的事情、text-shadow 向文本设置阴影、white-space（不是css3属性）

##### CSS3字体

##### CSS3 2D转换

transform

##### CSS3 3D转换

transform

##### CSS3 过渡

transition-property、transition-duration、transition-timing-function

##### CSS3 动画

@keyframes 规则用于创建动画。用关键词 "from" 和 "to"，等同于 0% 和 100%。、通过animation属性将动画绑定到选择器上

##### CSS3 多列

column-count 属性规定元素应该被分隔的列数、column-gap 属性规定列之间的间隔、column-rule 属性设置列之间的宽度、样式和颜色规则

##### CSS3 用户界面

resize 属性规定是否可由用户调整元素尺寸、box-sizing 以确切的方式定义适应某个区域的具体内容、outline-offset 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓

### px，em，rem区别

**px** 相对长度单位，是相当于显示器的分辨率而言的

**em** 相对长度单位，相对父元素的字体大小而言的

**rem** 相对长度单位，相对html根元素的字体大小而言的，css3新增元素

### 清除浮动的四种方式及其原理理解

1.  利用clear样式
2.  父元素结束标签之前插入清除浮动的块级元素
3.  利用伪元素
4.  利用overflow清除浮动 

>   clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;}
>
>   给浮动元素父级设置高度
>
>   父级同时浮动（需要给父级同级元素添加浮动）
>
>   父级设置成inline-block，其margin: 0 auto居中方式失效
>
>   给父级添加overflow:hidden 清除浮动方法
>
>   万能清除法 after伪类 清浮动（现在主流方法，推荐使用）

```css
float_div:after{
content:".";
clear:both;
display:block;
height:0;
overflow:hidden;
visibility:hidden;
}
.float_div{
zoom:1
}
```

### **display:none 和 visibility: hidden的区别**

>   display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。
>
>   visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。

### **position的absolute与fixed共同点与不同点**

>   共同点： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上
>
>   不同点： absolute的”根元素“是可以设置的 fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。

### **transition和animation的区别**

>   Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性， 而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。
>
>   transition 规定动画的名字 规定完成过渡效果需要多少秒或毫秒 规定速度效果 定义过渡效果何时开始 animation 指定要绑定到选择器的关键帧的名称

### **为什么css放在顶部而js写在后面**

```text
1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了
2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。
3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验
但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面
```

###  iframe 有那些缺点？

*iframe 会阻塞主页面的 Onload事件；

*iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

使用 iframe之前需要考虑这两个缺点。如果需要使用iframe， 最好是通过 javascript

动态给 iframe添加 src 属性值，这样可以绕开以上两个问题。

## JavaScript

### 创建一个对象

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sing = function () {
    alert(this.name)
  }
}
```

### 谈谈对this对象的理解？

this 是 js 的一个关键字，随着函数使用场合不同，this 的值会发生变化。

但是总有一个原则，那就是 this 指的是调用函数的那 个对象。

this一般情况下：是全局对象 Global。 作为方法调 用，那么 this 就是指这个对象

>全局作用域下的this指向window
>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素
>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window
>自执行函数中的this永远指向window
>定时器中函数的this指向window
>构造函数中的this指向当前的实例
>call、apply、bind可以改变函数的this指向
>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this

this绑定函数的执行上下文，谁调用它，它就指向谁。分为默认绑定、显式绑定、隐式绑定、apply/call/bind绑定、new绑定和箭头函数绑定

默认绑定:严格模式下this指向undefined，非严格模式this指向window

call、apply、bind都可以改变this的指向，但是apply接收参数数组，call接收的是参数列表 bind接收的是参数列表，但是apply和call调用就执行，bind需要手动执行

箭头函数绑定:箭头函数的this是父作用域的this，不是调用时的this,其他方法的this是动态的，而箭头函数的this是静态的

```js
window.name='a'
const obj={
    name:'b',
    age:22,
    getName:()=>{
        console.log(this)
        console.log(this.name)
    },
    getAge:function(){
        setTimeout(()=>{
            console.log(this.age)
        })
    }
}
obj.getName();//window a
obj.getAge();//22
```

优先级:箭头函数>new绑定>显示绑定/apply/bind/call>隐式绑定>默认绑定

### New创建对象发生了什么，用代码写出来

```js
var obj={};
obj._proto_=Base.prototype;
Bash.call(obj);
```

1.  创建一个空对象，并且this变量引用该对象，同时还继承了这个函数的原型
2.  属性和方法被加入到this引用的对象里
3.  新创建的对象由this引用，最后隐式返回this

### JSON 的了解？

JSON(JavaScript Object Notation) 是一种轻量 级的数据交换格式。它是基于 JavaScript的一个子 集。数据格式简单, 易于读写, 占用带宽小 {'age':'12', 'name':'back'}

### js延迟加载的方式有哪些？

defer和 async、动态创建 DOM 方式（用得最多）、 按需异步载入 js

### ES5的继承和ES6的继承有什么区别？

ES5的继承时通过prototype或构造函数机制来实现。**ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上**（Parent.apply(this)）。

ES6的继承机制完全不同，**实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this**。

具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。

ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。

### **es6新特性**

说的越多越好

**1. const 和 let**

`let`: 声明在代码块内有效的变量。

特点：

1.  在存在变理提升（不能在变量声明之前使用）
2.  let的暂时性死区： 其实与1差不多，只要在块作用域有声明，就不能在本作用域声明前用主个变量。
3.  不允许重复声明。

`const`: 声明一个只读的常量

特点：

1.  一但声明，这个值不能被改变（对于引用类型，是引用的地址不能被改变）
2.  声明时必须赋值

>   面试中常会问到var let const 三都的区别，回答的时候注重各自的特点，其实const let就是弥补var 的各种缺点，两都的特点就是var 的缺点。
>   工作中声明变量多用const 和 let
>   其中当声明的变量为引用类型如Array，如果没有直接更改引用的地址，可以使用const

**2. 解构赋值**

什么是解构赋值？

按照一定模式从数组或对象中提取值，然后对变量进行赋值（先提取，再赋值）

数组：

```js
let [a, b] = [1, 2]
// 以下的结果为右边数剩下的值所组成的数组
let [c, d ,...e] = [1, 2, 3, 4]
// 有默认值的写法
let [f = 100] = []  // f = 100
// 其中String也被视为类数组
let [a, b] = 'abcd' // a = a; b = b
```

对象:

变理名要与对象的属性名一样才可以：

```text
let { foo } = { foo: 1, bar: 2 } // foo = 1
// 重新命名（后面那个才是新变量）
let { foo: newFoo } = { foo: 1, bar: 2 } // newFoo = 1
```

实际使用：

1.  交换两个变量的值

```js
[x, y] = [y, x]
```

\2. 函数的封装

```js
function fn({ x, y } = {}) {
console.log(x, y)
}
```

其中，函数参数为一个对象，不会像`(x, y)`的形式这样固定参数的顺序，而`{} = {}`后面又赋一个空的对象就是为了在调用fn时不传参数而不会抛出错误导至程序中止

\3. 函数返回值的解构

函数返回多个值

```js
// 有次序的
function foo() {
return [a, b, c]
}
const [a, b, c] = foo()
// 无次序的
function foo() {
return { a, b, c}
}
const { b, a, c} = foo()
```

**3. 模板字符串**

```js
const h = 'hello'
`${ h } word`
```

`${}`中可以使用任意的javaScript表达试、运算、引用对象属性、函数调用等。结果是其返回值。

可以换行，但是所有的空格和换行会被保留。

特点：

可以换行，但是所有的空格和换行会被保留。

`${}`中可以使用任意的javaScript表达试、运算、引用对象属性、函数调用等。结果是其返回值。

**4. 函数的扩展**

1.  函数的默认值

```js
function m(x = 1) {}
```

\2. rest参数（用于获取函数的多余参数）

```js
function a(...values) {
// value 是一个数组，第个元素是传入的各个参数
}
```

\3. 函头函数

特点：

1.  函数体内的this = 定义时所在的对像
2.  不可以当作构造函数（不能用new)
3.  不可以用arguments对像，可以用rest
4.  不可以用yield命令（不能用作Generator函数）

>   阮老师的书中这一章讲到了有关尾调用，尾递归的内容，值得一看。

**5. 数组的扩展**

1.  扩展运算符。
2.  用于替代数组的`apply`。

call apply bind的区别：
用于改变this的指向， 第一个参数为this指向的对像，后面的参数是作为函数的参数。
区加在于：call apply 会即调用，而bind是生成一个等调用的函数。call bind参数是一个个用逗号罗列，而apply 是传入一个数组。

```js
fn.apply(null, [1, 2, 3])
fn.call(null, 1, 2, 3)
fn.bind(null, 1, 2, 3)()
// 指最大值
Math.max(...[3,4,5,62,8])
```

1.  合并数组

```text
// ES5
[1, 2].concat(3)
// ES6
[1, 2, ...[3]]
```

1.  新增的方法
2.  Array.from()将类数组转为数组

-   可遍历的对象(iterable)(Set, Map)
-   类似数组的对

```text
{ '0': 'a', '1': 'b' }
```

1.  实例的方法

-   `find()``findIndex()`找出第一个符合条件的成页/下标（位置）
-   `entries()``keys()``values()` 用于遍历数组。（配合for...of)
-   `includes()` 是否存在指定无素(返回布尔值)

**5. 对象的扩展**

1.  属性的简写：

```js
let a = 100
{ a }
// 等同于
{ a: 100 }
```

方法名同样可以简写，vue中就常常用这种写法：

```js
export default {
name: 'VueComp',
data() {},
create() {},
}
// 等同于
export default {
name: 'VueComp',
data: function() {},
create: function() {},
}
```

\2. 属性名可心使用表达式：

```js
let foo = 'foo'
let obj = {
[foo]: 'fooValue'
}
```

\3. 新增一些方法：

-   Object.is()
-   Object.assign()
-   对像的一些遍历：

Object.keys(), Object.values(), Object.entries()

```js
for(let key of Object.keys(obj)) {}
for(let value of Object.values(obj)) {}
for(let [key,value] of Object.entries(obj)){}
```

-   扩展运算符（常用）(es2017新增，在webpack中要另外的babel转换)

**6. Symbol**

javascript又新增的一种数据类型（第七种，另外6种为：`Undefined`、`Null`、`Boolean`、`String`、`Number`、`Object`)

注：symbol作为对象的属性名时不会被`for...in`,`for...of`,`Object.keys()`识别；可以改用`Reflect.ownkeys`方法.

**7. Set、Map**

Set和map是ES6新增的数据结构。

-   Set

特点： 1. 类似数组，但其成员是唯一的。

1.  是一个构造函数。

用法：

 数组去重：

```js
[...new Set([1,1,1,2,3,4,3])]
Array.from(new Set([1,1,1,2,3,4,3]))
```

-   Map

特点：

1.  为了解决javascript的对象只能用了符串作为键的问题。

用法： （使用实例的set,get,delete方法增，查，删）

```js
const m = new Map()
const obj = {a: 'aa'}
m.set(obj, 'obj as key')
m.get(obj) // 'obj as key'
m.delete(obj)
```

也可以在new 时接受一个数组

```js
const obj = { a: 'aa'}
const m = new Map([
['name': 'ym'],
[obj, { b: 'bbbb' }]
])
```

>   这段时间有一个很火的文章讲如何使用map组构来优化长长的if..else的

**8. Promise**

是异步编程的一种解决方案。

特点：

1.  状态不受外界影响（有三种状态：padding, fulfilled,redected)
2.  一旦状态改变就不会再变。

用法：

```js
const p = new Promise((resolve, reject) => {
setTimeout(() => {
resolve()
}, 1000)
}).then(res => {})
.catch(err => {})
```

注： then方法有两个参数，第一个是成功的回调，第二个为失败的回调，即：

```js
.then(res =>{}, err => {})
```

但是最好用catch方法， 因为catch方法会捕获then里的错误，then里有错误程序不会中止。

**Promise.all()**

将一组promise再包装成一个promise

```js
var pa = Promise.all([p1, p2, p3])
```

特点：

1.  当所有都fulfilledj时，promise.all才fulfilled
2.  当只有一个rejected时，promise.all就会rejected

**Iterator和for...of**

Iterator的3个作用：

1.  为各种数据提供统一的，简便的访问接口
2.  使数据结构的成员能按某种次序排列
3.  主要供for...of用

原生有iterator的数据结构：

```
Array`, `Map`, `Set`, `String`, `TypeArray`, `arguments`， `NodeList
```

(object是没有的)

**for...of与其他循环的比较**

1.  for循环写法比较麻烦
2.  数组的forEach: 无法用break;return跳出循环。
3.  For...in

-   数组的键名是数字，而for...in以字符串作为键名（也就是用for...in循环数组，其键名是字符串，笔者被坑过）
-   不仅可以遍历键名，还可以遍历手动添加的其他键，包括原型链上的
-   某些情况下，会心任意次序遍历
-   （ for...in主要为对象而设计的）

**9. Generator与async await**

generator是ES6提供的一种异步编程解决方案。使异步写法更像同步。

Async await是ES2017的标准，是generator的一个语法糖。

用法：

```js
async function a() {
await ...
console.log(111)
await ...
}
```

当执行a时，其不会阻塞涵数外面的代码（a内的代码会安顺序执行）

```js
console.log('开始')
a()
console.log('a后面')
// 开始 -> a后面 -> 111
```

**10. Class**

产生的原因： 原ES5语法的没有成型的类的概念。而面向对象编程又离不开类的概念。

ES5定义一个类:

```js
function Point(x, y) {
this.x = x;
this.y = y;
}
  
var p = new Point(1, 2)
```

ES6的class:

```js
class Point {
constructor(x, y) {
this.x = x;
this.y = y;
}
}
```

其中：

1.  constructor方法是类的默认方法，通过new 命令生成对象时会调用该方法，如果声明类时没有定义constructor，会默认定义一个空的。
2.  生成实例时必须用new ,不用会报错
3.  不存在变里提升（选定义类，再new实例）

**类的静态方法：**

所有在类中定义的方法都会被实例继承，如果不想被继承，可以在定义时加上static。表示为静态方法。

```js
class Foo {
static match() {}
}
Foo.match()
const f = new Foo()
f.match() // 报错
```

**类的静态属性**

很遗憾，ES6没有给类设静态属性，但是可以用以下方法定义(有提案，写方同静态方法)

```js
class Foo {}
Foo.porp = 1
// 使用
Foo.porp // 1
```

**类的实例属性**

类的方法默认被实例继承，那么属性呢？也是继承的，写法如下：

```js
class Foo {
myProp = 111;
...
}
```

**classr的继承 extends**

```js
class Point {}
class PointSon extends Point {
constructor(x, y, z) {
super(x, y)
this.z = z
}
}
```

其中：

1.  super等同于父类的constructor。
2.  子类必须在constructor中调用super， 也就是说用extends去继承一个类，就必须调用这个类（父类）的constructor。是因为子类没有自己的this对象，而是继承父类的this，然后对其进行加工
3.  如果了类没有写constructor，会默认生成一个，并包含了super(...args)

**11. Module**

一种将程序拆分成一个个小模块的支持，或者说是可以将一个个小模块加入到程序中去。

在ES6的module之前，比较流行的模块加载方案有:CommonJS和AMD，前者用于服务器（node)，后者用于浏览器。

区别：

1.  CommondJS和AMD是运行时加载的。
2.  module是编译时加载的。
3.  CommondJS输出的是值的复制，而ES6输出的是值的引用

**ES6模块默认使用严格模式**：

-   变里必须声明后再使用
-   函数的参数不能有同名属性
-   不能使用width
-   禁止this指向全局对象

**使用**

命令有： `export`、`import` 、`export default`

文件a.js

```js
export a = 1
export b = 2
```

相当于

```js
const a = 1;
const b = 2;
export { a, b }
```

在文件b.js中引入

```js
import { a, b } from './a.js'
```

引入是重命名

```js
import { a as reA, b as reB } from './a.js' // reA reB是重命名的变量
```

整体引入：

```js
import * as all from './a.js'
all.a // 1
all.b // 2
// all 相当于{ a, b }
```

**export default默认输出**

export default导出的模块在引入时可以自定义命名

```js
export default function() {
...
}
```

依然用import 引入,但是不用{}，且可以自定义变量名

```js
import name from './a.js'
name()
```

**从一个模块导入，然后再导出**

```js
// 写法一：
import { a, b } from './a.js'
export { a, b }
// 写法二：
export { a, b } from './a.js'
// 改名导出
export { a as reA, b } from './a.js'
// 整体导出
export * from './a.js'
```

**在浏览器中使用module**

将script标签的type设为module即可

```html
<!-- 方法一 -->
<script type="module" src="./a.js"></script>
<!-- 方法二 -->
<script type="module">
import { a } from './a.js'
</script>
```

其中：

-   type="module"的script内写的代码是在当前作用域，不是在全局。
-   模块内自动采用严格模式
-   顶层的this指向undefined
-   同一个模块如棵加载多次，只执行一次

### es6的class的es5的类有什么区别

```js
1.es6 class内部定义的方法都是不可枚举的
2.es6 class必须用new调用
3.es6 class不存在变量提升
4.es6 class默认使用严格模式
5.es6 class子类必须在父类的构造函数中调用super(),才有this对象；而es5是先有子类的this，再调用
```

### **`==和===区别是什么？`**

>   =赋值
>
>   ==返回一个布尔值；相等返回true，不相等返回false； 允许不同数据类型之间的比较； 如果是不同类型的数据进行，会默认进行数据类型之间的转换； 如果是对象数据类型的比较，比较的是空间地址
>
>   === 只要数据类型不一样，就返回false；

### **移动端的兼容问题**

>   给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend
>   移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上 尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。 用fastclick，[github.com/ftlabs/fast…](https://link.zhihu.com/?target=https%3A//github.com/ftlabs/fastclick) 用preventDefault阻止a标签的click 消除 IE10 里面的那个叉号 input:-ms-clear{display:none;}
>   设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。
>
>   圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport
>
>   设置用户截止缩放，一般写视口的时候就已经写好了。

### **typeof和instance of 检测数据类型有什么区别？**

>   相同点： 都常用来判断一个变量是否为空，或者是什么类型的。
>
>   不同点： typeof 返回值是一个字符串，用来说明变量的数据类型 instanceof 用于判断一个变量是否属于某个对象的实例.

### **如何判断一个变量是对象还是数组（prototype.toString.call()）。**

```text
千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。
```

>   typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。
>
>   installOf() 用来判断A是否是B的实例，installof检查的是原型。
>
>   toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。
>
>   hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。
>
>   isProperty()方法测试一个对象是否存在另一个对象的原型链上。

### **使元素消失的方法**

```js
visibility:hidden、display:none、z-index=-1、opacity：0
1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发
2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件
3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉
```

### 实现页面加载进度条

### **常见的设计模式有哪些？**

```text
1、js工厂模式
2、js构造函数模式
3、js原型模式
4、构造函数+原型的js混合模式
5、构造函数+原型的动态原型模式
6、观察者模式
7、发布订阅模式
```

### 事件委托

### 实现extend函数

### 为什么会有跨域的问题以及解决方式？

### jsonp原理、postMessage原理？

### 实现拖拽功能，比如把5个兄弟节点中的最后一个节点拖拽到节点1和节点2之间

### 动画：setTimeout何时执行，requestAnimationFrame的优点

### 手写parseInt的实现：要求简单一些，把字符串型的数字转化为真正的数字即可，但不能使用JS原生的字符串转数字的API，比如Number()

### 写一个通用的事件侦听器函数

```js
// event(事件)工具集，来源： https://github.com/markyun markyun.Event = {

// 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); };
}

}, // 视能力分别使用 dom0||dom2||IE方式 来 绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent('on' + type, function() { handler.call(element); }); } else { element['on' + type] = handler; }

}, // 移除事件 removeEvent : function(element, type,handler) { if (element.removeEnentListener) { element.removeEnentListener(type, handler, false); } else if (element.datachEvent) { element.detachEvent('on' + type, handler); } else { element['on' + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为 IE不支持 事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; }

}, // 取消事件的默认行为 preventDefault : function(event) {if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; }

}, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取 event对象的引用，取到事件的所有信 息，确保随时能使用 event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev && Event == ev.constructor) { break; }c = c.caller;}} return ev;}};
```



### 异步加载的方式

(1) defer， 只支持 IE

(2) async：

(3) 创建 script， 插入到 DOM中， 加载完毕 后 callBack

documen.write和 innerHTML的区别

document.write只能重绘整个页面

innerHTML可以重绘页面的一部分

### **async await函数**

>   async/await函数是异步代码的新方式
>
>   async/await是基于promise实现的
>
>   async/await使异步代码更像同步代码
>
>   await 只能在async函数中使用，不能再普通函数中使用，要成对出现
>
>   默认返回一个promise实例，不能被改变
>
>   await下面的代码是异步，后面的代码是同步的

### **JS中同步和异步,以及js的事件流**

>   同步：在同一时间内做一件事情
>
>   异步：在同一时间内做多个事情 JS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。

### JS中常见的异步任务
定时器、ajax、事件绑定、回调函数、async await、promise

### 22.TCP的三次握手和四次挥手
三次握手

>   
>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；
>   第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接
>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；
>   四次挥手
>   
>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；
>   第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成
>   第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕
>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；

### 为什么建立连接是三次握手，而断开连接是四次挥手呢?
建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

### 事件流

DOM2事件流分为三个部分:事件捕获、处于目标、事件冒泡。

**事件冒泡**是指事件从执行的元素开始往上层遍历执行

**事件捕获**是指事件从根元素开始从外向里执行

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<button id="btn">click Me</button>  
<script>
let btn=document.getElementById('btn');
btn.onclick=fucntion(e){
    console.log(e)
}
</script>
</body>
</html>
```

点击按钮后，事件冒泡的执行顺序是:button->body->html->document

事件捕获的执行顺序则相反:document->html->body->button

### **前端事件流**

```text
事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。
  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到<html>再到<body>就停止了。
      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。
      3、冒泡阶段：事件又传播回文档
   阻止冒泡事件event.stopPropagation()
	  function stopBubble(e) {
    		if (e && e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器
      		e.stopPropagation()
    		} else {
      		window.event.cancelBubble = true //IE方式阻止冒泡
    	      }
  		   }
   阻止默认行为event.preventDefault()
 function stopDefault(e) {
    if (e && e.preventDefault) {
      e.preventDefault()
    } else {
      // IE浏览器阻止函数器默认动作的行为
      window.event.returnValue = false
    }
  }
```

### **事件如何先捕获后冒泡？**

>   在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果， 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。
>
>   哪些事件不支持冒泡事件：鼠标事件：mouserleave mouseenter 焦点事件：blur focus UI事件：scroll resize

### **target和currentTarget区别**

target是事件的真正目标

currentTarget是事件处理程序注册的元素

**document.ready和window.onload区别**

document.ready是dom树加载后执行，而window.onload是整个页面资源加载完后执行，所以document.ready比window.onload先执行

### **setTimeout、setInterval区别**

两者都是定时器，设定一个150ms后执行的定时器不代表150ms后定时器会执行，它表示代码在150ms内会被加入队列，如果这个时间点队列没有其他逻辑在执行，表面上看代码在精确时间执行了。在队列中有其他逻辑时，代码等待时间会超过150ms

**setTimeout** 只执行一次

**setInterval** 执行多次，属于重复定时器

```text
因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的
待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码
```

### 从浏览器返回html到渲染出页面，再到中间涉及到的优化点？**前端有哪些页面优化方法?**

>   减少 HTTP请求数
>   从设计实现层面简化页面
>   合理设置 HTTP缓存
>   资源合并与压缩
>   合并 CSS图片，减少请求数的又一个好办法。
>   将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
>   多图片网页使用图片懒加载。
>   在js中尽量减少闭包的使用
>   尽量合并css和js文件
>   尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片
>   减少对DOM的操作
>   在JS中避免“嵌套循环”和 “死循环”
>   尽可能使用事件委托（事件代理）来处理事件绑定的操作

（看雅虎 14 条性能优化原则）

（1） 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托 管，data缓存 ，图片服务器。

（2） 前端模板 JS+数据，减少由于 HTML 标签导 致的带宽浪费，前端用变量保存 AJAX 请求结果，每 次操作本地变量，不用请求，减少请求次数

（3） 用 innerHTML 代替 DOM操作， 减少 DOM 操作次数，优化 javascript 性能。

（4） 当需要设置的样式很多时设置 className 而不是直接操作 style。

（5） 少用全局变量、缓存 DOM 节点查找的结果。 减少 IO 读取操作。

（6） 避免使用 CSS Expression（css 表达式)又 称 Dynamic properties(动态属性)。

（7） 图片预加载，将样式表放在顶部，将脚本放 在底部 加上时间戳。

（8） 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。

### **浏览器渲染原理及流程 DOM -> CSSOM -> render -> layout -> print**

```text
流程：解析html以及构建dom树 -> 构建render树 ->  布局render树 -> 绘制render树
概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树
      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）
      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置
      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点

重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上
	触发重绘的条件：改变元素外观属性。如：color，background-color等
	重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观
注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局

重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。
	每个页面都需要一次回流，就是页面第一次渲染的时候

重排一定会影响重绘，但是重绘不一定会影响重排
```

>   将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。



### DOM和css如何解析，如何渲染出元素？

### **回流和重绘区别**

回流：当渲染树中元素尺寸、结构或者某些属性发生变化时，浏览器重新渲染部分或全部页面的情况叫回流。下列元素改变引发回流:

-   getBoundingClientRect()
-   scrollTo()
-   scrollIntoView()或者scrollIntoViewIfneeded
-   clientTop、clientLeft、clientWidth、clientHeight
-   offsetTop、offsetLeft、offsetWidth、offsetHeight
-   scrollTop、scrollLeft、scrollWidth、scrollHeight
-   getComputedStyle()

重绘：当页面中元素样式变化不会改变它在文档流中的位置时，即不会使元素的几何属性发生变化，浏览器会将新样式赋给它并重新绘制页面(比如color、backgroundColor)

>   频繁回流和重绘会引起性能问题

避免方法:

-   减少table布局使用
-   减少css表达式的使用(如calc())
-   减少DOM操作，用documentFragment代替
-   将元素设为display:none;操作结束后把它显示回来，因为display:none不会引发回流重绘
-   避免频繁读取会引发回流重绘的元素，如果需要最好是缓存起来
-   对复杂动画元素使用绝对定位，使它脱离文档流
-   减少使用行内样式

### **防抖节流**

节流:多次触发事件时，一段时间内保证只调用一次。以动画为例，人眼中一秒播放超过24张图片就会形成动画，假设有100张图片，我们一秒播放100张过于浪费，一秒播放24张就够了。

防抖:持续触发事件后，时间段内没有再触发事件，才调用一次。以坐电梯为例，电梯10s运行一次。如果快要运行时进来一个人，则重新计时。

```js
//节流
function throttle(fn,delay) {
  let timer=null
  return function () {
    if(!timer){
      timer=setTimeout(()=>{
        fn.call(this,arguments)
        timer=null
      },delay)
    }
  }
}
//防抖
function debounce(fn,delay) {
  let timer=null
  return function () {
    if(timer){
      clearTimeout(timer)
    }
    timer=setTimeout(()=>{
      fn.call(this,arguments)
    },delay)
  }
}
```

### 什么是防抖和节流？有什么区别？如何实现？

**防抖**

>   触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间

-   思路：

>   每次触发事件时都取消之前的延时调用方法

```js
function debounce(fn) {
      let timeout = null; // 创建一个标记用来存放定时器的返回值
      return function () {
        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
          fn.apply(this, arguments);
        }, 500);
      };
    }
    function sayHi() {
      console.log('防抖成功');
    }

    var inp = document.getElementById('inp');
    inp.addEventListener('input', debounce(sayHi)); // 防抖
```

**节流**

>   高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

-   思路：

>   每次触发事件时都判断当前是否有等待执行的延时函数

```text
function throttle(fn) {
      let canRun = true; // 通过闭包保存一个标记
      return function () {
        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
        canRun = false; // 立即设置为false
        setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
          fn.apply(this, arguments);
          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
          canRun = true;
        }, 500);
      };
    }
    function sayHi(e) {
      console.log(e.target.innerWidth, e.target.innerHeight);
    }
    window.addEventListener('resize', throttle(sayHi));
```

### js为什么需要放在body(更好的回答其实是浏览器的渲染引擎和js解析引擎的冲突，当然回答js是单线程执行也没问题,如何优化)？

### 操作DOM为什么是昂贵的？

### js如何执行(even Loop/宏任务、微任务，事件队列，promise,async/await)？

### **异步回调（如何解决回调地狱）**

```text
promise、generator、async/await
promise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理
	  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱
	  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）
	  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败
		promise.all() 里面状态都改变，那就会输出，得到一个数组
		promise.race() 里面只有一个状态变为rejected或者fulfilled即输出
		promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）
```

### **浏览器事件循环和node事件循环**

浏览器事件循环:

1.  同步任务在主线程执行，在主线程外还有个任务队列用于存放异步任务
2.  主线程的同步任务执行完毕，异步任务入栈，进入主线程执行
3.  上述的两个步骤循环，形成eventloop事件循环 浏览器的事件循环又跟宏任务和微任务有关，两者都属于异步任务。

>   js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入任务队列，再执行微任务，将微任务放入任务队列，他俩进入的不是同一个任务队列。往外读取的时候先从微任务里拿这个回调函数，然后再从宏任务的任务队列上拿宏任务的回调函数

宏任务:

-   script
-   定时器 setTimeout setInterval setImmediate

微任务:

-   promise
-   process.nextTick()
-   MutationObserver

node事件循环：

1.  timer阶段
2.  I/O 异常回调阶段
3.  空闲预备阶段
4.  poll阶段
5.  check阶段
6.  关闭事件的回调阶段

### js的作用域？

**全局作用域**

>   浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域 一个页面只有一个全局作用域，全局作用域下有一个window对象 window是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下） 如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值 如果变量只被var过，那么存储值是undefined 在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量

**私有作用域**

>   函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域） 私有作用域在全局作用域中形成，具有包含的关系； 在一个全局作用域中，可以有很多个私有作用域 在私有作用域下定义的变量都是私有变量 形参也是私有变量 函数体中通过function定义的函数也是私有的，在全局作用域不能使用；

**块级作用域**

>   es6中新引入的一种作用域 在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域 var obj = {} //对象的大括号不是块级作用域 块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错） 作用域链

**上级作用域**

>   函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系 作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链 当前作用域没有的，则会继续向上一级作用域查找 当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）

### **你怎样看待闭包（closure）？**

简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一。

另一个作用，则是保护变量不受外界污染，使其一直存在内存中。

在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。

```js
function say667(){
  // Local variable that ends up within closure
  var num = 666;
  var sayAlert = function () {
    alert(num);
  }
  num ++;
  return sayAlert;
}
var sayAlert = say667(); 
sayAlert()//执行结果应该弹出的 667
```

执行 say667()后,say667()闭包内部变量会存在, 而 闭包内部函数的内部变量不会存在.使得 Javascript 的垃圾回收机制 GC 不会收回 say667()所占用的 资 源，因为 say667()的内部函数的执行需要依赖 say667()中的变量。这是对闭包作用的非常直白的描 述.

### 基础类型以及如何判断类型？

### 事件机制以及如何实现一个事件队列？

### js深浅拷贝？

浅克隆: 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。

深克隆： 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 JSON.parse、JSON.stringify()

浅拷贝:

-   concat()
-   Object.assign()
-   slice()
-   手写

```js
function shallowCopy(obj){
  if(typeof obj==='function'&& obj!==null){
    let cloneObj=Array.isArray(obj)?[]:{}
    for(let prop in obj){
      if(obj.hasOwnProperty(prop)){
        cloneObj[prop]=obj[prop]
      }
    }
    return cloneObj
  }
  else{
    return obj
  }
}
```

深拷贝:

-   JSON.stringfy(JSON.parse())

>   上面的方法不能解决循环引用，也不能显示函数或undefined

-   手写深拷贝

```js
var deepClone=(obj,map=new WeakMap())=>{
  if(map.get(obj)){
    return obj
  }

  let newObj;
  if(typeof obj==='object'&& obj!==null){
    map.set(obj,true)
    newObj=Array.isArray(obj)?[]:{};
    for(let item in obj){
      if(obj.hasOwnProperty(item)){
        newObj[item]=deepClone(obj[item])
    }
  }
    return newObj;
  }
  else {
    return obj;
  }
};
```

### 都有哪些方式创建对象，静态和动态,构造函数创建对象优缺点

1：Object构造函数创建

```js
var Person =new Object();
Person.name = 'Jason';Person.age = 21;
```

2.  使用对象字面量表示法来创建对象

```js
var Person={};   //等同于var Person =new Object();
var Person={
name:"Jason",
age:21
}
```

3.  使用工厂模式创建对象

```js
function createPerson(name,age,job)
{ var o = new Object(); 
o.name = name; 
o.age = age; 
o.job = job; 
o.sayName = function()
{  alert(this.name);  };
 return o;
 }
var person1 = createPerson('Nike',29,'teacher');
var person2 = createPerson('Arvin',20,'student');
```

4.  使用构造函数创建对象

```js
function Person(name,age,job)
{ this.name = name; 
this.age = age; 
this.job = job; 
this.sayName = function(){ alert(this.name); }; 
}
var person1 = new Person('Nike',29,'teacher');
var person2 = new Person('Arvin',20,'student');
```

5.  原型创建对象模式

```js
function Person(){}
Person.prototype.name = 'Nike';
Person.prototype.age = 20;
Person.prototype.jbo = 'teacher';
Person.prototype.sayName = function(){ alert(this.name);};
var person1 = new Person();person1.sayName();
```

6.  组合使用构造函数模式和原型模式

```js
function Person(name,age,job)
{ this.name =name; 
this.age = age;
 this.job = job;}
Person.prototype = { 
constructor:Person,
 sayName: function()
{ alert(this.name); };
}
var person1 = new Person('Nike',20,'teacher');
```



4.  

### **js继承方式有哪些？**

>   原型链继承 核心： 将父类的实例作为子类的原型
>
>   构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类
>
>   实例继承 核心：为父类实例添加新特性，作为子类实例返回
>
>   拷贝继承
>
>   组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现 函数复用
>
>   寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实 例方法/属性，避免的组合继承的缺点

### 你是如何理解原型和原型链的？

>   把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 __proto__存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过__proto__向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined

**原型**

>   所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象 prototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类 所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型

### 原型链、说一下继承 

继承与原型链息息相关。

`JavaScript` 中没有类的概念的，主要通过原型链来实现继承。通常情况下，继承意味着复制操作，然而 `JavaScript` 默认并不会复制对象的属性，相反，`JavaScript` 只是在两个对象之间创建一个关联（原型对象指针），这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。

```js
//原型链继承
function Parent(){
    this.property=true;
}
Parent.prototype.getValue=function(){
    return this.property;
}
function Son(){
    this.subProperty=false;
}
Son.prototype=new Parent();
let instance=new Son();
```

原型链继承继承了原型的属性和方法，但是有几个缺点:

1.  原型链中包括引用类型的值时，会被所有实例共享
2.  不能实现子类向超类的构造函数中添加属性

由此产生了借用构造函数继承,解决了原型链继承的缺点，它自身又有缺点:不能实现函数复用

```js
//借用构造函数继承
function Parent(){
    this.property=true;
}
function Son(){
    Parent.call(this);
}
复制代码//组合继承
function Parent(){
    this.property=true;
    this.colors=['red','purple','orange']
}
Parent.prototype.getPro=function(){
    return this.property;
}
function Son(property,name){
    Parent.call(this,property);
    this.name=name;
}
Son.prototype=new Parent()
```

组合继承避免了原型链和借用构造函数的缺陷,是最常用的继承之一

```js
//原型继承
var a = {
  friends : ["yuki","sakura"]
};
var b = Object.create(a);
b.friends.push("ruby");
var c = Object.create(a);
c.friends.push("lemon");
alert(a.friends);//"yuki,sakura,ruby,lemon"
```

原型继承缺点跟原型链继承一样，也是引用类型的属性会被所有实例共享

```js
//寄生式继承,可以类比设计模式的工厂模式
function createAnother(obj){
  var clone = object(obj);
  clone.sayHi = function(){
    console.log("hello");
  };
  return clone;
}
```

寄生式继承不能做到函数复用

```js
//寄生组合式继承
function Parent(name){
    this.name=name;
    this.colors=['red','white','gray']
}
Parent.prototype.getName=function(name){
    this.name=name
}
function Son(name,age){
    Parent.call(this,name);//第二次调用Parent()
    this.age=age;
}
Son.prototype=new Parent()//第一次调用Parent()
Son.prototype.constructor=Son;
Son.prototype.getAge=function(){
    return this.age;
}
```

寄生组合式继承避免了在子实例上创建多余的属性，又能保持原型链不变，还能正常使用instanceof()和isPrototypeOf()，是最理想的继承方式。

es6方法的继承:通过extends实现

```js
class Parent(){
    constructor(){}
}
class Son extends Parent(){
    constructor(){
        super()
    }
}
```

### 数组去重

```js
//方法一 使用ES6的Set
function filterArr(arr) {
  return new Set(arr)
}
//方法二:filter+indexOf()判断，如果数字不是第一次出现则被过滤
function filterArr2(arr){
  let newArr=arr.filter((item,index)=>{
    return arr.indexOf(item)===index
  })
  console.log(newArr)
}
//方法三:双重for循环
function filterArr3(arr){
  let isRepeat,newArr=[];
  for(let i=0;i<arr.length;i++){
    isRepeat=false
    for(let j=i+1;j<arr.length;j++){
      if(arr[i]===arr[j]){
        isRepeat=true
        break
      }
    }
    if(!isRepeat){
      newArr.push(arr[i])
    }
  }
  return newArr
}
//方法四:哈希表
function filterArr4(arr){
  let seen={}
  return arr.filter(function (item) {
    return seen.hasOwnProperty(item)?false:(seen[item]=true)
  });
}
//方法五:sort排序，相同的数字会排在相邻n个位置
function filterArr5(arr){
  let lastArr=[]
  const newArr=arr.sort((a,b)=>{
    return a-b
  })
  for(let i=0;i<newArr.length;i++){
    if(newArr[i]!==newArr[i+1]){
      lastArr.push(newArr[i])
    }
  }
  return lastArr
}
```

ES6的set对象 先将原数组排序，在与相邻的进行比较，如果不同则存入新数组

```text
function unique(arr){
    var arr2 = arr.sort();
    var res = [arr2[0]];
    for(var i=1;i<arr2.length;i++){
        if(arr2[i] !== res[res.length-1]){
        res.push(arr2[i]);
    }
}
return res;
}
利用下标查询
 function unique(arr){
    var newArr = [arr[0]];
    for(var i=1;i<arr.length;i++){
        if(newArr.indexOf(arr[i]) == -1){
        newArr.push(arr[i]);
    }
}
return newArr;
}
```

### **call bind apply 的区别？**

>   call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。
>
>   call()和apply()的区别就在于，两者之间的参数。
>
>   call()在第一个参数之后的 后续所有参数就是传入该函数的值。
>
>   apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是 直接执行该函数。他的参数和call()相同。



### **箭头函数和普通函数区别**

-   箭头函数没有prototype，所以箭头函数本身没有this
-   箭头函数的this指向在定义的时候继承自外层第一个普通函数的this
-   箭头函数没有arguments，普通函数有
-   使用new调用箭头函数会报错
-   不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

### **Promise处理异步**

>   他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式” new Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)== Promise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行 Promise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法) then()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject ajax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成

### 手写promise 

```js
function myPromise(executor) {
    let self=this;
    self.status='pending';
    self.value=undefined;
    self.reason=undefined;

    function resolve(value) {
        if(self.status==='pending'){
            self.value=value
            self.status="resolved"
        }
    }
    function reject(reason) {
        if(self.status==='pending'){
            self.reason=reason
            self.status=status
        }
    }
    try{
        executor(resolve,reject)
    }
    catch (e) {
        reject(e)
    }
}
```

**手写bind**

```js
Function.prototype.myBind=function(context,...args){
   const fn=this
    args=args?args:[]
    return function newFn(...newFnArgs) {
        if(this instanceof newFn){
            return new fn(...args,...newFnArgs)
        }
        return  fn.apply(context,[...args,...newFnArgs])
    }
}
```

###  **手写call、apply**

```js
Function.prototype.myCall=function(context,...args){
    context=context||window
    args=args?args:[]
    const key=Symbol()
    context[key]=this
    const result=context[key](...args)//通过隐式绑定的方式调用函数
    delete context[key]//删除添加的属性
    return result//返回函数调用的返回值
}

Function.prototype.myApply=function(context,args){
    context=context||window
    args=args||[]
    const key=Symbol()
    context[key]=this
    const result=context[key](...args)
    delete context[key]
    return result
}
```

### 对异步的理解 

js是单线程的，但不能一直等着一张张图片加载完成吧，写一个回调的函数，谁先完成任务就执行谁。

### node的理解以及应用方面，优缺点？

js开发环境  **在线聊天**    **对象数据库顶层的 API**   **队列输入**   **数据流**    **代理**    **股票交易商的数据界面**   **应用监控仪表板**     **系统监控仪表板**    **服务器端 Web 应用**    

*（优点）因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，

因此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。

此外，与 Node 代理服务器交互的客户端代码是由 javascript 语言编写的，

因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，

而且缺少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子。

### 伪数组 

定义：

1、拥有length属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)
2、不具有数组所具有的方法

### 伪数组怎么转化为数组？ 

1.  创建一个新数组，遍历这个伪数组，并将其每一项添加到新数组中。
2.  使用`[].slice.call(obj)`， 数组的`slice()`方法,它返回的是数组，使用`call`或者`apply`指向伪数组
3.  使用扩展运算符`...`，比如使用`[...obj]`，需要保证obj是可迭代
4.  使用`ES6`中数组的新方法 `Array.from`，此种方法，对数据源没有特殊的要求，数据源可以不能迭代

### 怎么判断一个元素是不是数组？ 

1.  instanceof  a instanceof Array; //true

2.  constructor 

    let a = [1,3,4];
    a.constructor === Array;//true

3.  Object.prototype.toString.call()

    let a = [1,2,3]
    Object.prototype.toString.call(a) === '[object Array]';//true

4.  Array.isArray()

    let a = [1,2,3]
    Array.isArray(a);//true

### 除了你说的Array.isArray和Array.from还有哪些数组的方法？ 

var a = Array(3);创建一个数组

ES6 Array.of() 返回由所有参数值组成的数组

ES6 Arrary.from() 将两类对象转为真正的数组

改变原数组的方法(9个):

splice() 添加/删除数组元素

sort() 数组排序

pop() 删除一个数组中的最后的一个元素

shift() 删除数组的第一个元素

push() 向数组的末尾添加元素

unshift()

reverse() 颠倒数组中元素的顺序

ES6: copyWithin() 指定位置的成员复制到其他位置

ES6: fill() 填充数组

不改变原数组的方法(8个):

slice() 浅拷贝数组的元素

join() 数组转字符串

toLocaleString() 数组转字符串

toString() 数组转字符串 不推荐

cancat

ES6扩展运算符`...`合并数组

indexOf() 查找数组是否存在某个元素，返回下标

lastIndexOf() 查找指定元素在数组中的最后一个位置

ES7 includes() 查找数组是否包含某个元素 返回布尔

遍历方法(12个):

ES5：    forEach、every 、some、 filter、map、reduce、reduceRight、   

ES6：    find、findIndex、keys、values、entries

### **splice和slice、map和forEach、 filter()、reduce()的区别**

```text
 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，
 包含从start到end（不包含该元素）的数组方法
	注意：该方法不会更新原数组，而是返回一个子数组
 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）
	splice(index, howmany,item1,...itemx)
		·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置
		·howmany参数：必须，要删除的数量，
		·item1..itemx:可选，向数组添加新项目
3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据
4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素
5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值
6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理	
```

### map和forEach的区别

**相同点**

>   都是循环遍历数组中的每一项 forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个 匿名函数中的this都是指向window 只能遍历数组

**不同点**

>   map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。) map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）
>   **注意**：forEach对于空数组是不会调用回调函数的。

### Ajax同步和异步的区别?

1. 通过异步模式，提升了用户体验

2. 优化了浏览器和服务器之间的传输，减少不必要 的数据往返，减少了带宽占用

3. Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。

### Ajax的最大的特点是什么？

Ajax 可以实现动态不刷新（局部刷新） readyState 属性 状态 有 5 个可取值：0=未初始化 ，1=正在加载 2=以加载，3=交互中，4=完成

### jax 的缺点？

1、ajax 不支持浏览器 back 按钮。

2、安全问题 AJAX 暴露了与服务器交互的细节。

3、对搜索引擎的支持比较弱。

4、破坏了程序的异常机制。

5、不容易调试。

### **Ajax的四个步骤**

>   1.创建ajax实例
>
>   2.执行open 确定要访问的链接 以及同步异步
>
>   3.监听请求状态
>
>   4.发送请求

### **ajax中get和post请求的区别**

>   get 一般用于获取数据
>   get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；
>   get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；
>   get安全性较低
>   get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳
>   post 一般用于发送数据
>   post传递参数，需要把参数放进请求体中，发送给服务器；
>   post请求参数放进了请求体中，对大小没有要求；
>   post安全性比较高；
>   post请求不会走缓存；

### **get/post的区别**

```text
1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提交的数据放在http包的Body中
2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制
3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值
4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上
```

### get请求传参长度的误区、get和post请求在缓存方面的区别

**误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。**

实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:

-   HTTP 协议 未规定 GET 和POST的长度限制
-   GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度
-   不同的浏览器和WEB服务器，限制的最大长度不一样
-   要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte

补充补充一个get和post在缓存方面的区别：

-   get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。
-   post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。

## VUE

### 说说你对SPA单页面的理解，它的优缺点分别是什么?

SPA ( single- page application)仅在Web页面初始化时加载相应的HTML、JavaScript 和CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转;取而代之的是利用路由机制实现HTML内容的变换，UI 与用户的交互，避免页面的重新加载。

-   用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染;基于上面一点，SPA相对对服务器压力小;
-   前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理;
-   初次加载耗时多:为实现单页Web应用功能及显示效果,
    需要在加载页面的时候将JavaScript、cSS统一加载， 部分页面按需加载;
-   前进后退路由管理:由于单页应用在一-个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理;
-   SEO难度较大:由于所有的内容都在一个页面中动态替换显示，所以在SEO.上其有着天然的弱势。

### **聊聊对vue的理解**

>   vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的

### VUE的指令有哪些？

```css
v-if 用于条件渲染
v-show 用于条件渲染，两者的区别请参考下一个问题
v-for 用于列表渲染
v-on  监听事件
v-bind 动态绑定
v-html 渲染html元素
v-model 数据双向绑定
```

### 怎么理解Vue的单向数据流？

所有的prop都使得其父子prop之间形成了一个单向下行绑定:父级prop的更新会向下流动到子组件中，但是反过来则不行。
这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
额外的，每次父级组件发生更新时，子组件中所有的prop都将会刷新为最新的值。
这意味着你不应该在-个子组件内部改变prop。如果你这样做了，Vue会在浏览器的控制台中发出警告。
子组件想修改时，只能通过$emit派发-个自定义事件，父组件接收到后，由父组件修改。
●这个prop用来传递-个初始值;这个子组件接下来希望将其作
为一个本地的prop数据来使用。在这种情况下，最好定义一个本地的data属性并将这个prop用作其初始值:
props: [ ' initialCounter'],
data: function () {
return {
counter: this . initialCounter
}

●这个prop以一种原始的值传入且需要进行转换。在这种情况
下，最好使用这个prop的值来定义一个计算属性
props: [ 'size'],
computed: {
normalizedSize: .
function () {
return this. size. trim( ) . toLowerCase( )
}
}

### **Vue的双向数据绑定，V-model的原理是什么？**

**Vue的双向数据绑定**是由数据劫持结合发布者订阅者实现的。 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。 在数据变动时作你想做的事

**原理** 通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新 在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据

### **v-if和v-show区别**

v-if是真正的条件渲染,因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建;也是惰性的:如果在初始渲染时条件为假，则什么也不做一直 到条件第一次变为真时，才会开始渲染条件块。

v-show就简单得多不管初始条件是什么，元素总是会被渲染,
并且只是简单地基于CSS的"display"属性进行切换。

所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景;v-show则适用于需要非常频繁切换条件的场景。

### **v-for和v-if为什么不能放于同一级**

v-for优先级高于v-if，放于同级可能会重复渲染两次v-if，建议把v-for放于v-if所在的外层元素

### **nextTick**

原理:eventloop事件循环

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

### **v-for中key的原理**

```js
key 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。不指定key时，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试
就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。
```

### vue生命周期

```js
1.beforeCreate
 初始化界面前
2.created
  初始化界面后，拿到data，props，methods、computed和watch
3.beforeMount
 渲染dom前
4.mounted
 渲染dom后，拿到$el
5.beforeUpdate
 更新前
6.updated
 更新后，拿到更新后的dom
7.beforeDestroy
 卸载组件前
8.destroyed
 卸载组件后
9.activated
 被 keep-alive 缓存的组件激活时调用
10.deactivated
 被 keep-alive 缓存的组件停用时调用
11. errorCaptured
 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例
 以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。
```

**父子组件通信**

```js
父传子:prop

子传父:$emit

父子通信:
+ eventbus
+ vuex
+ ref结合$parent或 $children

跨层级较多:provide/inject
```

### **computed和watch区别和运用的场景？**

**computed:**是计算属性，依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一 次获取computed的值时才会重新计算computed的值;
**watch:**更多的是「观察」的作用，类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作;

-   当我们需要进行数值计算，并且依赖于其它数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算;
-   当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作(访问一个API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

### vue的底层

博客里。

### vue里，数据改变怎么触发页面渲染，如果没有节点使用这个数据，会是什么样的过程

### vue的双向绑定原理

```js
vue的双向绑定是通过数据劫持和发布者-订阅者模式实现的，数据劫持又是通过Object.defineProperty()实现的

Object.defineProperty(data,'a',{
    enumerable:true,//是否可枚举
    writable:true,//是否可写
    configurable:true,//是否可配置
    get(){
        return this.a//读取data对象的a属性时，触发get方法
    },
    set(val){
        this.a=val;//修改data对象的a属性时，触发set方法
    }
})
mvvm的数据变化更新视图，是通过Object.defineProperty()实现的；视图更新变化数据，是通过事件监听实现的。

发布者-订阅者的实现过程:
1. 实现一个监听器Observer，劫持并监听所有属性，如果有变化，就通知订阅者
2. 实现一个订阅者Watcher，收到属性的变化通知并执行响应的函数，从而更新视图
3. 实现一个解析器Compiler，可以扫描并解析每个节点的相关指令，初始化模板数据和对应的订阅器
```

### **vuex的流程**

```text
页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。
mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中
通过mapGetter来动态获取state中的值
```

### **vnode的diff算法原理**

虚拟dom是对真实dom的一种映射，新旧Vnode比较同层级的节点，然后根据两者的差异只更新有差异的部分，生成新的视图，而不是对树进行逐层搜素遍历，因此时间复杂度是O(n)。虚拟dom可以减少页面的回流和重绘，提升性能

### **vuex有哪几种状态和属性**

>   state中保存着共有数据，数据是响应式的
>   getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用
>   mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的
>   actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。
>   modules：模块化vuex

### **vue路由的两种模式**

>   hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。
>   history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法
>   这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。

### **vue中 key 值的作用**

>   当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。
>
>   key的作用主要是为了高效的更新虚拟DOM。

### **DOM diff原理**

>   如果元素类型发生变化，直接替换
>   如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引

### **`$route`和`$router`的区别**

>   $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
>   $router是“路由实例”对象包括了路由的跳转方法，钩子函数等。

### vue-router守卫

>   导航守卫 router.beforeEach 全局前置守卫
>   to: Route: 即将要进入的目标（路由对象）
>   from: Route: 当前导航正要离开的路由
>   next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。
>   next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
>   next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。

```text
// main.js 入口文件
    import router from './router'; // 引入路由
    router.beforeEach((to, from, next) => { 
      next();
    });
    router.beforeResolve((to, from, next) => {
      next();
    });
    router.afterEach((to, from) => {
      console.log('afterEach 全局后置钩子');
    });
```

路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫

```text
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫

```text
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开
    // 可以访问组件实例 `this`
    // 比如还未保存草稿，或者在用户离开前，
    将setInterval销毁，防止离开之后，定时器还在调用。
  }
}
```

### **vue修饰符**

>   stop：阻止事件的冒泡
>   prevent：阻止事件的默认行为
>   once：只触发一次
>   self：只触发自己的事件行为时，才会执行

### **vue项目中的性能优化**

>   1.不要在模板里面写过多表达式
>
>   2.循环调用子组件时添加key
>
>   3.频繁切换的使用v-show，不频繁切换的使用v-if
>
>   4.尽量少用float，可以用flex
>
>   5.按需加载，可以用require或者import()按需加载需要的组件
>
>   6.路由懒加载

### vue.extend和vue.component

>   extend 是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里 还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。
>   Vue.component 你可以创建 ，也可以取组件。
>
>   常见的兼容问题
>   png24位的图片在iE6浏览器上出现背景 解决方案是做成PNG8.也可以引用一段脚本处理.
>
>   浏览器默认的margin和padding不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。
>
>   IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。
>
>   浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}

### 状态管理 

### 3、Class与Style如何动态绑定?
Class可以通过对象语法和数组语法进行动态绑定:
●对象语法:

```js
<div v-bind:class="{ active: isActive, ' text-danger' : hasError }"></di
data: {
isActive: true,
hasError: false
}
```

●数组语法:
```js
<div v-bind:class="[ isActive ? activeClass : '' ，errorClass]"></div>
data: {
activeClass :
active ' ,
errorClass :
' text-danger
}
```

Style也可以通过对象语法和数组语法进行动态绑定:
●对象语法:

```js
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }">
data: {
activeColor:' red' ,
fontSize: 30
}
```

数组语法:
```js
<div v-bind: style="[ styleColor, styleSize]"></div>
data: (
styleColor: [
color:' red '
],
styleSize: [
fontSize: ' 23px
]
]
```

### 使用前端框架（angular/vue/react）带来哪些好处，相对于使用jQuery

### **VUE和REACT有什么区别？**

>   react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；
>
>   vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。

```text
=>  相同点：
	1.数据驱动页面，提供响应式的试图组件
	2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范
	3.数据流动单向，都支持服务器的渲染SSR
	4.都有支持native的方法，react有React native， vue有wexx
=>  不同点：
	1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
	2.数据渲染：大规模的数据渲染，react更快
	3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
	4.开发风格：react推荐做法jsx + inline style把html和css都写在js了
		    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
```

## react

**redux中的reducer（纯函数）**

```text
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state ->  action ->  state
```

**3.react的refs**

```text
refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，
它将接受地城dom元素或组件的已挂在实例，作为第一个参数
```

**4.react中的keys**

```text
帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它
```

**5.React的生命周期**

```text
三个状态：Mounting(已插入真实的DOM）
	  Updating(正在被重新渲染)
	  Unmounting(已移除真实的DOM)
componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，
componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用
```

**6.React子组件向父组件传值**

```text
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。
```

**7.为什么虚拟DOM会提高性能 [www.zhihu.com/question/29…](https://www.zhihu.com/question/29504639?sort=created)**

```text
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能
具体实现步骤：
	·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中
        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异
	·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
```

**8.diff算法**

```text
1.把树形结构按照层级分解，只比较同级元素
2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记
3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面
Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用
react只会匹配相同的class的component（这里的class指的是组件的名字）
合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制
4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能	
```

**9.简述下flux的思想**

```text
flux的最大特点，就是数据的‘单向流动’
1.用户访问View
2.View发出用户的Action
3.Dispatcher收到Action,要求state进行相应的更新
4.store更新后，发出一个‘change’事件后，更新页面
```

**10.reac性能优化是哪个周期函**

```text
shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，
如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能
```

**11.react怎么划分业务组件和技术组件**

```text
根据组件的职责通常把组件分为UI组件和容器组件
UI组件负责UI的呈现，容器组件负责管理数据和逻辑
两者通过React-redux提供connect方法联系起来
```

**12.setState**

```text
setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列
而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值	
那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误

同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state

同步更新state:
	setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。
	第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行
	也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步

例子：componentDidMount() {

	fetch('https://test.com')
    
	.then((res) => res.json())
    
	.then(
    (data) => {
this.setState({ data:data });
			StatusBar.setNetworkActivityIndicatorVisible(false);
        }
```



### React的生命周期

>   beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。
>   created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有
>   beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点
>   mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点
>   beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器
>   updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环
>   beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件
>   destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁

### Jquery与 jQuery UI 有啥区 别？

*jQuery 是一个 js 库，主要提供的功能是选择器， 属性修改和事件绑定等等。

*jQuery UI则是在 jQuery的基础上， 利用 jQuery的扩展性， 设计的插件。

提供了一些常用的界面元素，诸如对话框、拖动 行为、改变大小行为等等

### jquery 中如何将数组转化为 json字符串， 然 后 再转化回来？

jQuery中没有提供这个功能， 所以你需要先编写两 个 jQuery 的扩展：

```js
$.fn.stringifyArray = function(array) { return JSON.stringify(array) }
$.fn.parseArray = function(array) { return JSON.parse(array) }
```

然后调用： 

$("").stringifyArray(array)

### 有用过jQuery是哈 那你觉得jQuery和React开发各自的优缺点是什么？ 

### 你觉得在开发[项目]()的时候React性能好还是jQuery性能好？ 

### React好在什么地方？

### 什么情况下不应该选择React而需要选择jQuery？ 

### 用jQuery选择的元素和js选择器选择的元素一样吗？

### 怎么让jQuery元素对象和js的dom对象转化 

### 你们开发的时候 选择的是哪个版本的React 

### Ant design用过哪些组件？ 

### 自己封装过组件吗？ 

### 用过model组件吧，现在我要自己封装一个，说一下思路 

### react组件通信 

### 受控组件跟非受控组件 

## 工具 

### npm 模块安装机制

-   发出`npm install`命令

-   查询node_modules目录之中是否已经存在指定模块

-   -   若存在，不再重新安装

    -   若不存在

    -   -   npm 向 registry 查询模块压缩包的网址
        -   下载压缩包，存放在根目录下的`.npm`目录里
        -   解压压缩包到当前项目的`node_modules`目录

### npm 实现原理

输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：

1.  **执行工程自身 preinstall**当前 npm 工程如果定义了 preinstall 钩子此时会被执行。
2.  **确定首层依赖模块**首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。
    工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。
3.  **获取模块**
    获取模块是一个递归的过程，分为以下几步：

-   获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。
-   获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。
-   查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。

### package.json文件

管理你所安装的npm包的依赖，在开发过程中能清楚的查询安装的包的版本以及项目中使用的包依赖，便于开发组成员共享。以及项目的配置信息（比如名称、版本号、项目描述、许可证等元数据）。运行npm install命令可以自动下载package.json文件中运行和开发环境中所需的依赖

name  version  description  keywords  homepage  hugs  license  author  files  main  repository  scripts  config  dependencies  devDependencies  engines  private

### package.json里面dev是干嘛的？

devDependencies字段是一个对象，它指定了项目开发时依赖的模块名和版本范围映射。如果有人要用你的模块，但他们可能不需要你开发所使用的外部测试或者文档框架。

### 详细讲讲cdn 

**CDN（内容分发网络）**

**CDN是**内容分发网络（Content Delivery Network或Content Ddistribute Network），**主要的功能是**解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。

**它的原理是**广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术
将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）

**资源上传cdn之后，当用户访问cdn的资源地址之后会经历下面的步骤：**

- 首先经过本地的dns解析，请求cname指向的那台cdn专用的dns服务器。
- dns服务器返回全局负载均衡的服务器ip给用户
- 用户请求全局负载均衡服务器，服务器根据ip返回所在区域的负载均衡服务器ip给用户
- 用户请求区域负载均衡服务器，负载均衡服务器根据用户ip选择距离近的，并且存在用户所需内容的，负载比较合适的一台缓存服务器ip给用户。当没有对应内容的时候，会去上一级缓存服务器去找，直到找到资源所在的源站服务器，并且缓存在缓存服务器中。用户下一次在请求该资源，就可以就近拿缓存了。

### git 常用命令哪些？ 

git init、git config、git add、git commit、git push、git featch、git branch、git checkout

### 如何设计突发大规模并发架构？

先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等

编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

标注样式编写人，各模块都及时标注（标注关键样式 调用的地方）；

页面进行标注（例如 页面 模块 开始和结束）；

CSS跟 HTML 分文件夹并行存放，命名都得统一 （例 如 style.css）

JS 分文件夹存放 命民以该 JS 功能为准英文翻译；

图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理

## webpack

### **webpack运行流程**

分为初始化、编译、输出三个阶段.

**初始化**：

1.  从配置文件和shell文件读取、合并参数；
2.  加载plugin
3.  实例化compiler

**编译**

1.  从entry发出，针对每个module串行调用对应loader翻译文件内容
2.  找到module依赖的module，递归进行编译处理

**输出**：

1.  把编译后module组合成chunk
2.  把chunk转换成文件，输出到文件系统

### webpack性能优化

优化可以从两个方面考虑，一个是优化开发体验，一个是优化输出质量。

**优化开发体验**

-   缩小文件搜索范围。涉及到webpack如何处理导入文件，不再赘述，不会的可以自行搜索。由于loader对文件转换操作很耗时，应该尽量减少loader处理的文件，可以使用include命中需要处理的文件，缩小命中范围。
-   使用DllPlugin，提升构建速度
-   使用happyPack开启多线程
-   使用UglifyJs压缩代码(只支持es5)，uglifyes支持es6，两个插件不能同时开启。使用ParalellUgifyPlugin开启多个子进程压缩，既支持UglifyJs又支持uglifyes
-   使用自动刷新：监听到代码改变后，自动编译构建可运行代码并刷新页面
-   开启模块热替换:在不刷新网页的同时实现实时预览

**优化输出质量**减少首屏加载时间

-   区分环境
-   压缩代码
-   CDN加速
-   使用Tree shaking
-   提取公共代码
-   按需加载

提升流畅度，即代码性能:

-   使用PrePack优化代码运行时的效率
-   开启Scope Hoisting，让webpack打包出来的代码更小、运行更快

### **loader的原理**

loader能把源文件翻译成新的结果，一个文件可以链式经过多个loader编译。以处理scss文件为例:

-   sass-loader把scss转成css
-   css-loader找出css中的依赖，压缩资源
-   style-loader把css转换成脚本加载的JavaScript代码

### plugin原理

plugin用于扩展webpack功能。

-   webpack启动后，在读取配置时会先执行new BasicPlugin(options)初始化一个BasicPlugin获得它的实例
-   调用BasicPlugin.apply(compiler）给插件实例传递compiler对象
-   插件实例获取compiler对象后，通过compiler.plugin(事件名，回调函数)监听webpack广播出的事例



## 计算机网络

### **从输入url地址到页面相应都发生了什么？**

1.  DNS解析
2.  TCP连接
3.  发送HTTP请求
4.  服务器处理请求并返回HTTP报文
5.  浏览器解析渲染页面
6.  连接结束

```text
1、浏览器的地址栏输入URL并按下回车。
2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。
4、根据IP建立TCP连接（三次握手）。
5、HTTP发起请求。
6、服务器处理请求，浏览器接收HTTP响应。
7、渲染页面，构建DOM树。
8、关闭TCP连接（四次挥手）
```

```text
1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存
2.浏览器与服务器建立tcp链接（三次握手）
3.浏览器向服务器发送http请求(请求和传输数据）
4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器
5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤
6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来
```

### url从输入到输出的过程

1. 构建请求
    构建请求行，请求行包括请求方法、请求http版本、URI
    Get/Http/1.0
2. 查找强缓存
    检查强缓存，命中则直接使用，否则检查协商缓存
3. DNS解析
    域名与IP地址映射
4. 建立tcp连接
    chrome限制同一域名下最多6个tcp连接
    -   通过三次握手建立连接
        -   三次握手过程:
            1.客户端向服务器发送连接请求，传递一个数据包syn，此时客户端处于SYN_SEND状态
            2.服务器接收syn报文后，会以自己的syn报文作为应答，传递数据包syn+ack,此时服务器处于SYN-REVD状态
            3.客户端接收syn报文后，发送一个数据包ack，此时客户端处于ESTABLISHED状态，双方已建立连接
    -   进行数据传输
    -   通过四次挥手断开连接
        -   四次挥手过程:
            1. 客户端发送一个FIN报文，报文中指定一个序列号，此时客户端处于FIN_WAIT1状态，等待服务器确认
            2. 服务器接收到FIN后，会发送ACK确认报文，表明已经收到客户端报文，此时服务端处于CLOSE_WAIT2状态
            3. 服务器发送FIN，告诉客户端想断开连接，此时服务端处于LAST_CHECK阶段
            4. 客户端收到FIN后，一样发送一个ACK作为应答，此时客户端处于TIME_WAIT阶段。需要过一段时间确认服务端收到自己的ACK报文
                后才会进入CLOSED状态
            5. 发送http请求
            6. 网络响应
            7. 浏览器解析和渲染
                分为构建dom树、样式计算、生成布局树。
            8. 生成布局
                触发回流和重绘

**介绍下半连接队列**

```js
服务器第一次接收到客户端的SYN后，会处于SYN-REVD阶段，此时双方还没有建立完全的连接，
服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称为半连接队列

已经完成三次握手并建立连接，就叫全连接队列
```



### http由哪些字段组成 

Start line、Headers、Body

![image-20201016211209757](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201016224906.png)



### **客户端缓存**

客户端缓存分为cookie、localStorage、sessionStorage、indexedDB，网上有关的文章很多，就不详细说了

### **浏览器缓存**

**强缓存**

不向http发送请求，返回状态码304.

检查强缓存有两个字段: http1.0使用expires，代表过期时间，但是服务器时间和客户端时间可能不一致。为了弥补这个缺点，http1.1使用cache-control的max-age字段，cache-control有多个指令

-   public 允许客户端和代理服务器缓存
-   private 允许客户端缓存
-   no-store 不使用缓存
-   no-cache 使用协商缓存 两个字段都存在，cache-control优先级高于expires

**协商缓存**向http发送请求，返回状态码200

检查协商缓存有两个字段: http1.0使用last-modified，即最后修改时间。

1.  在浏览器向服务器发送请求后，服务器会在响应头上加上这个字段
2.  浏览器接收后，如果再次请求，会在请求头上携带If-Modified-Since
3.  服务器拿到If-Modified-Since字段后，会和服务器中该资源的最后修改时间对比,如果请求头中这个值小于最后修改时间，更新资源；否则返回304，告诉浏览器直接使用缓存

http1.1使用etag，etag是服务器根据当前文件内容，给文件生成的唯一标识，只要内容改变，这个值就会变。etag优先级高于last-modifed

缓存位置，按优先级从高到低分别是:

-   service worker
-   memory cache
-   disk cache
-   push cache

### 优化中会提到缓存的问题，问：静态资源或者接口等如何做缓存优化

### **token、cookie、session三者的理解？？？！！！**

```text
1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式    

2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名
    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）

3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）
    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```



### **js中跨域方法**

>   同源策略（协议+端口号+域名要相同）
>
>   1、jsonp跨域(只能解决get） 原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容
>   步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据
>
>
>   2、document.domain 基础域名相同 子域名不同
>
>   3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name
>
>   4、服务器设置对CORS的支持 原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求
>
>   5、利用h5新特性window.postMessage()

### http缓存（如果有cdn会怎么样 +3

博客里。

### http三次握手四次挥手，tcp的包有序号吗？tcp为什么需要三次握手 

博客里。

### Linux相关

**如何查看系统内核的版本**    cat /proc/version

**如何查看系统当前的 IP 地址**    ifconfig -a

**如何查看磁盘还有多少剩余空间**      df -ah 

**如何在系统中管理服务**    service

**如何查看文件夹大小**    du -h --max-depth=1

**如何查看你系统中开放的端口号**    netstat 

**如何查看某个进程对 CPU 的使用情况**      top或者ps

**修改文件夹目录权限**   chmod 777 mm.txt

**服务器传送命令**  scp -P 5722 -r pathA root@211.82.97.237:pathB

**Linux统计文本行数**    wc - lcw file1 file2

### OSI七层模型和TCP/IP四层模型

OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。

![https://img-blog.csdn.net/20180411120702438?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTIxNTU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201213170755.png)

![image-20201213170932876](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201213170933.png)

### 三次握手和四次挥手

三次握手：

![img](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201213174515.png)

第一次握手：建立连接时，[客户端](http://baike.baidu.com/view/930.htm)发送[syn](http://baike.baidu.com/view/488528.htm)包（syn=j）到[服务器](http://baike.baidu.com/view/899.htm)，并进入[SYN_SENT](http://baike.baidu.com/view/840439.htm)状态，等待服务器确认；SYN：同步序列编号（**Synchronize Sequence Numbers**）。

[第二次握手](http://baike.baidu.com/view/205949.htm)：[服务器](http://baike.baidu.com/view/899.htm)收到[syn](http://baike.baidu.com/view/488528.htm)包，必须确认客户的SYN（[ack](http://baike.baidu.com/view/204040.htm)=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入[SYN_RECV](http://baike.baidu.com/view/1520054.htm)状态；

第三次握手：[客户端](http://baike.baidu.com/view/930.htm)收到[服务](http://baike.baidu.com/view/133203.htm)器的SYN+ACK包，向[服务器](http://baike.baidu.com/view/899.htm)发送确认包ACK([ack](http://baike.baidu.com/view/204040.htm)=k+1），此包发送完毕，客户端和服务器进入[ESTABLISHED](http://baike.baidu.com/view/1137549.htm)（TCP连接成功）状态，完成三次握手。

**四次挥手：**

![img](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201213174601.png)

1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

【问题3】为什么不能用两次握手进行连接？

答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

​    现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### **tcp和udp区别**

1.  tcp只能一对一通信，udp可以一对一、一对多、多对多通信，即支持多播和广播
2.  tcp首部开销消耗32字节，udp仅消耗8个字节
3.  tcp适合对数据安全性要求高的场景，比如文件传输，udp适合对数据实时性要求高的场景，比如视频通话、语音通话
4.  tcp是有状态连接，udp是无状态的连接
5.  tcp-可靠传输 udp-不可靠传输
6.  tcp-面向字节流 udp-面向报文

### **tcp怎么保证可靠性**

```js
1. 超时重传机制
2. 对失序数据进行重排序
3. 应答机制
4. 滑动窗口
5. 拥塞控制
```

### tcp拥塞控制

博客里。

### dns查询过程数据怎么流动的  

博客里。  

### http协议说一下 

```text
1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
4.http请求信息request：
	请求行（request line）、请求头部（header）,空行和请求数据四部分构成

	请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
	请求头部，用来说明服务器要使用的附加信息
	空行，请求头部后面的空行是必须的
	请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
	状态行、消息报头、空行和响应正文

	状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
	消息报头，用来说明客户端要使用的一些附加信息
	空行，消息报头后面的空行是必须的
	响应正文，服务器返回给客户端的文本信息。
```

### 说一下https和http的区别

```text
https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密
http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少
```

1.  http基于TCP/IP协议，https基于SSL/TLS协议
2.  http默认端口号为80，https默认端口号为443
3.  https安全性更强，需要CA证书
4.  https可以防止运营商劫持

>   可以介绍https的通信过程，涉及对称加密和非对称加密

### 为什么https安全？ 

博客里。

### 那https会不会带来性能问题？ 

### **http请求有哪几种**

**http1.0**：get、post、head

**http1.1**:put、delete、connect、trace、options

**简单请求**:

1.  请求method只能是get、post、head
2.  请求头只能是accept/accept-language/content-language/content-Type
3.  content-Type只能是text/plain、multipart/form-data、application/x-www-form-urlencoded

### **介绍http1.0|http1.1|http2.0**

**http1.0**:

1.  完成连接即断开，导致重新慢启动和三次握手
2.  线头阻塞，导致请求间相互影响

**http1.1**：

1.  用keep-alive支持长连接
2.  用host字段指定对应的虚拟站点
3.  新增功能: 断点续传、身份认证、状态管理、cache缓存->cache-control、expires、last-modified、etag

**http2.0**：

1.  二进制分帧层：应用层和传输层
2.  header头部压缩
3.  服务端推送
4.  多路复用

>   二进制分帧层可以扩展到计算机网络的OSI参考模型

```text
长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接
节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域

1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源
```

### **http状态码**

100-199 用于指定客户端应相应的某些动作。 

200-299 用于表示请求成功。 

300-399 用于已经移动的文件并且常被包含在 定位头信息中指定新的地址信息。

400-499 用于指出客户端的错误。

500-599 用于支持服务器错误。 

```js
200-请求成功
301-永久重定向
302和307-临时重定向
304-读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]
400-当前请求不能被服务器理解或请求参数有误
401-权限不够，请求需要认证或认证失败
403-服务器禁止访问
404-资源未找到
405-方法未允许
500-内部服务器错误
502-网关错误
503-服务不可用、服务器处于超负载或停机维护
```

### **了解nginx吗**

ngnix是个高性能反向代理服务器，有以下作用:

-   解决跨域
-   请求过滤
-   配置gzip
-   负载均衡
-   静态资源服务器

ngnix解决跨域的原理:

-   把后端域名设为前端服务的域名，然后设置相应的location拦截前端需要跨域的请求，最后将请求代理回服务端的域名
-   ngnix实现负载均衡的策略:轮询、最小链接数、最快响应时间

### 知道强缓存和协商缓存吗？说一下 

博客里。

### 说一下协商缓存的详细流程

**web缓存**

```text
1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本
2.缓存的好处
        （1）减少不必要的请求
    （2）降低服务器的压力，减少服务器的消耗
    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）
```

## 性能优化

### 说几条web前端优化策略?

(1). 减少HTTP请求数

这条策略基本上所有前端人都知道，而且也是最重要最有效的。都说要减少HTTP请求，那请求多了到底会怎么样呢？首先，每个请求都是有成本的，既包 含时间成本也包含资源成本。一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个“漫长”而复杂的过程。 时间成本就是用户需要看到或者“感受”到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。

另外，由于浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给 用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。减少HTTP请求数的主要途径包括：

(2). 从设计实现层面简化页面

如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。

(3). 合理设置HTTP缓存

缓存的力量是强大的，恰当的缓存设置可以大大的减少HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出78个请求，共600多K 数据（如图1.1），而当第二次访问即浏览器已缓存之后访问则仅有10个请求，共20多K数据（如图1.2）。（这里需要说明的是，如果直接F5刷新页面 的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是304响应，只有Header没有Body，可以节省带宽）

怎样才算合理设置？原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过HTTP Header中的Expires设置一个很长的过期头；变化不频繁而又可能会变的资源可以使用Last-Modifed来做请求验证。尽可能的让资源能够 在缓存中待得更久。

(4). 资源合并与压缩

如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外，CSS、Javascript、Image都可以用相应的工具进行压缩，压缩后往往能省下不少空间。

(5). CSS Sprites

合并CSS图片，减少请求数的又一个好办法。

(6). Inline Images

使用data: URL scheme的方式将图片嵌入到页面或CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在CSS中的图片则更为理想一些。

(7). Lazy Load Images

这条策略实际上并不一定能减少HTTP请求数，但是却能在某些条件下或者页面刚加载时减少HTTP请求数。对于图片而言，在页面刚加载的时候可以只 加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。有啊首页曾经的做法 是在加载的时候把第一屏之后的图片地址缓存在Textarea标签中，待用户往下滚屏的时候才“惰性”加载。

### 一、webpack打包文件体积过大？（最终打包为一个js文件）

```text
1.异步加载模块
2.提取第三库
3.代码压缩
4.去除不必要的插件
```

### **二、如何优化webpack构建的性能**

```text
一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积
		 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理
		 3.对一些组件库采用按需加载，避免无用的代码
二、减少目录检索范围
		 ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度
	
三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias
```

### 三、移动端的性能优化

```text
  1、首屏加载和按需加载，懒加载
  2、资源预加载
  3、图片压缩处理，使用base64内嵌图片
  4、合理缓存dom对象
  5、使用touchstart代替click（click 300毫秒的延迟）
  6、利用transform:translateZ(0)，开启硬件GUP加速
  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明
  8、使用viewport固定屏幕渲染，加速页面渲染内容
  9、尽量使用事件代理，避免直接事件绑定
```

### 四、Vue的SPA 如何优化加载速度

```text
1.减少入口文件体积
2.静态资源本地缓存
3.开启Gzip压缩
4.使用SSR,nuxt.js
```

### 五、移动端300ms延迟

```text
由来：
300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，
当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作
因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕
       
解决方案：1.禁用缩放，设置meta标签 user-scalable=no
	  2.fastclick.js
		原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即
		      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉
fastclick.js还可以解决穿透问题
```

### 六、页面的重构；

>   在不改变外部行为的前提下，简化结构、添加可读性

## **web安全**

### **常见的web安全及防护原理**

```text
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，
            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，
            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
		防范：1.对用户输入进行校验
		       2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。
		        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
			防范：1.尽量采用post而不使用get提交表单
			      2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
			举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据
			防范：在客服端页面增加伪随机数，通过验证码
XSS和CSRF的区别：
   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包
   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包
```

### **xss**

跨站脚本攻击，指攻击者在网页上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时， 对客户端浏览器进行控制或获取用户隐私数据的方式

**防范**：

1.  httpOnly防止截取cookie
2.  用户输入检查
3.  用户输出检查
4.  利用CSP（浏览器的内容安全策略）

### csrf

跨站请求伪造，劫持受信任用户向服务器发送非预期请求的方式。

**防范**：

1.  验证码
2.  referer check
3.  增加token验证

## 数据结构

在[LeetCode-write](/Users/suntian/codes/webproject/tianguoguoblog.io/_posts/2020-12-09-LeeCode-write.md)里

## 半结构化问答

### 说说你对前端的理解？

### 你说你热爱前端，那么应该 WEB 行业的发展很关注吧？ 说说最近最流行的一些东西吧？

### 你有了解我们公司吗？说说你的认识？

### 作为一名前端工程师，无论工作年头长短都应该必须 掌握的知识点有：

1、DOM 结构 —— 两个节点之间可能存在哪些 关系以及如何在节点之间任意移动。

2、DOM 操作 ——如何添加、移除、移动、复制、 创建和查找节点等。

3、事件 —— 如何使用事件，以及 IE 和标 准 DOM事件模型之间存在的差别。

4、XMLHttpRequest—— 这是什么、怎样完整 地执行一次 GET 请求、怎样检测错误。

5、严格模式与混杂模式 —— 如何触发这两种模 式，区分它们有何意义。

6、盒模型 —— 外边距、内边距和边框之间的关 系，及 IE8 以下版本的浏览器中的盒模型

7、块级元素与行内元素 —— 怎么用 CSS控制 它们、以及如何合理的使用它们

8、浮动元素——怎么使用它们、它们有什么问题 以及怎么解决这些问题。

9、HTML 与 XHTML——二者有什么区别，你觉得应该使用哪一个并说出理由。

10、JSON —— 作用、用途、设计结构。