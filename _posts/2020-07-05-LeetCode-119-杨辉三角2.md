---
layout:     post           # 使用的布局（不需要改）
title:      LeetCode-119-杨辉三角2
subtitle:   LeetCode-119-杨辉三角2 #副标题
date:       2020-07-05            # 时间
author:     甜果果                    # 作者
header-img: https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20200701171155.png  #背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - LeetCode
    - python

---

# LeetCode-[119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

<iframe width="560" height="315" src="https://www.youtube.com/embed/PKiV5HhnfDw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

tag: easy，数组

**题目：**

给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

![img](https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20200705222659.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**

```
输入: 3
输出: [1,3,3,1]
```

# 方法一：

输入的是3，其实返回的是第四行

和上一道题不太一样，因为只需要输出特定的行，所以不需要把所有的数字都生成，浪费空间，

result就是最终要生成的那一行，

row这一行有多少个数字呢？是row index+1的数字，也就是第0行有1个数字，

```python
class Solution:
    def getRow(self, rowIndex):
        result = [1] + [0] * rowIndex # 因为无论是哪一行，最开始的数字都是1
        
        for i in range(rowIndex):
            result[0] = 1
            for j in range(i+1, 0, -1): # 倒着加

                result[j] = result[j] + result[j-1]
        return result
    
i 0
j 1
[1, 1, 0, 0]
result [1, 1, 0, 0]
i 1
j 2
[1, 1, 1, 0]
j 1
[1, 2, 1, 0]
result (1, 2, 1, 0]
i 2
j 3
[1, 2, 1, 1]
j 2
[1, 2, 3, 1]
j 1
[1, 3, 3, 1]
result [1, 3, 3, 1]
[1, 3, 3, 1]
```

>执行用时：44 ms, 在所有 Python3 提交中击败了49.50%的用户
>
>内存消耗：13.6 MB, 在所有 Python3 提交中击败了11.11%的用户